---
interface Props {
    images?: any[];
    maxSize?: number;
    delayMs?: number;
    rotationRange?: number;
}

const {
    images = [],
    maxSize = 400,
    delayMs = 300,
    rotationRange = 30,
} = Astro.props;

// randomize every render
const shuffled = [...images].sort(() => Math.random() - 0.5);
---

<div class="windowWidth">
    <div
        id="gallery"
        data-max={maxSize}
        data-delay={delayMs}
        data-rot={rotationRange}
    >
        {
            shuffled.map((u) => (
                <img
                    class="photo"
                    src={u.src}
                    alt="some image"
                    decoding="async"
                />
            ))
        }
    </div>
</div>

<style>
    .windowWidth {
        position: relative;
        width: 100vw;
        margin-left: calc(50% - 50vw);
        overflow: hidden;
        padding-top: 1000px;
        margin-top: -1000px;
    }

    #gallery {
        position: relative;
        margin: auto;
        width: 80%;
        margin-bottom: 20em;
    }

    .photo {
        position: absolute;
        display: block;
        transform-origin: 50% 50%;
        user-select: none;

        border-radius: 0.2em;
        box-shadow: 0 0 8px var(--color-shadow);

        /* start invisible + slightly shifted */
        opacity: 0;
        transform: translateY(40px);

        transition:
            opacity 0.6s ease,
            transform 0.6s ease,
            width 2s ease,
            height 2s ease,
            left 0.5s ease,
            top 0.5s ease;
    }
</style>

<script is:inline>
    const container = document.getElementById("gallery");
    if (!container) {
        // nothing to do
    } else {
        const maxSize = Number(container.dataset.max || 360);
        const delayMs = Number(container.dataset.delay || 180);
        const rotRange = Number(container.dataset.rot || 30);
        const imgs = Array.from(container.querySelectorAll("img"));
        let placed = [];
        let currentY = 0;
        let currentZoomed = null;
        let initialLoadComplete = false;
        let initialWidth = 0;

        const triesPerImage = 60;
        const rand = (min, max) => Math.random() * (max - min) + min;

        function getUnitW() {
            const cw = container.clientWidth || 0;
            if (cw < 600) return maxSize * 0.4;
            if (cw < 900) return maxSize * 0.6;
            if (cw < 1200) return maxSize * 0.8;
            return maxSize;
        }

        function metrics() {
            const unitW = getUnitW();
            const bumpStep = unitW / 80;
            return { unitW, bumpStep };
        }

        function overlaps(a, b) {
            return !(
                a.x + a.w <= b.x ||
                b.x + b.w <= a.x ||
                a.y + a.h <= b.y ||
                b.y + b.h <= a.y
            );
        }

        function updateContainerHeight(bottom) {
            container.style.height = Math.ceil(bottom) + "px";
        }

        function resetImg(img) {
            const ow = Number(img.dataset.origW || 0);
            const oh = Number(img.dataset.origH || 0);
            const ol = Number(img.dataset.origLeft || 0);
            const ot = Number(img.dataset.origTop || 0);
            const rot = Number(img.dataset.origRot || 0);
            if (ow) img.style.width = ow + "px";
            if (oh) img.style.height = oh + "px";
            img.style.left = ol + "px";
            img.style.top = ot + "px";
            img.style.transform = `translateY(0px) rotate(${rot}deg)`;
            img.style.zIndex = "0";
            img.dataset.zoomed = "0";
        }

        function zoomImg(img) {
            const vw =
                window.innerWidth || document.documentElement.clientWidth || 0;
            const vh =
                window.innerHeight ||
                document.documentElement.clientHeight ||
                0;
            const origW = Number(img.dataset.origW || img.offsetWidth || 1);
            const origH = Number(img.dataset.origH || img.offsetHeight || 1);
            const maxScale = 3;
            const scale = Math.min(
                maxScale,
                (vw * 0.9) / origW,
                (vh * 0.9) / origH,
            );
            const targetW = origW * scale;
            const targetH = origH * scale;
            img.style.width = targetW + "px";
            img.style.height = targetH + "px";
            img.style.left = `calc(50% - ${targetW / 2}px)`;
            const scrollY = window.scrollY || window.pageYOffset || 0;
            const containerTop =
                container.getBoundingClientRect().top + scrollY;
            const centerTop = Math.max(
                0,
                scrollY + vh / 2 - targetH / 2 - containerTop,
            );
            img.style.top = centerTop + "px";
            img.style.transform = "rotate(0deg)";
            img.style.zIndex = "10";
            img.dataset.zoomed = "1";
        }

        function onPhotoClick(e) {
            const img = e.currentTarget;

            // only allow click if this image has been placed
            if (!img.dataset.origW) return;

            const isZoomed = img.dataset.zoomed === "1";
            if (isZoomed) {
                resetImg(img);
                currentZoomed = null;
                return;
            }
            if (currentZoomed && currentZoomed !== img) {
                resetImg(currentZoomed);
            }
            zoomImg(img);
            currentZoomed = img;
        }

        function decodeOne(img) {
            if (img.decode) {
                return img.decode().catch(() => {});
            }
            if (img.complete) return Promise.resolve();
            return new Promise((res) =>
                img.addEventListener("load", res, { once: true }),
            );
        }

        function delay(ms) {
            return new Promise((res) => setTimeout(res, ms));
        }

        function layoutOne(img, yStart) {
            const usableW = Math.max(0, container.clientWidth || 0);
            const { unitW, bumpStep } = metrics();
            const nw = img.naturalWidth || 1;
            const nh = img.naturalHeight || 1;
            let scale = Math.min(unitW / nw, unitW / nh, 1);
            scale *= rand(0.9, 1.1);
            const w = Math.round(nw * scale);
            const h = Math.round(nh * scale);
            let rot = rand(-rotRange, rotRange);
            if (!rot) rot = 3;
            let y = yStart;
            let x = 0;
            let ok = false;
            for (let attempt = 0; attempt < triesPerImage; attempt++) {
                const candX = rand(0, Math.max(0, usableW - w));
                const cand = { x: candX, y, w, h };
                ok = true;
                for (const p of placed) {
                    if (overlaps(cand, p)) {
                        ok = false;
                        break;
                    }
                }
                if (ok) {
                    x = candX;
                    break;
                }
                y += bumpStep;
            }
            if (!ok) {
                const maxX = Math.max(0, usableW - w);
                x = Math.max(0, Math.min(maxX, rand(0, maxX || 0)));
            }
            const left = Math.round(x);
            const top = Math.round(y);
            img.style.width = w + "px";
            img.style.height = h + "px";
            img.style.left = left + "px";
            img.style.top = top + "px";
            img.dataset.origW = String(w);
            img.dataset.origH = String(h);
            img.dataset.origLeft = String(left);
            img.dataset.origTop = String(top);
            img.dataset.origRot = String(rot);
            img.dataset.zoomed = "0";
            placed.push({ x: left, y: top, w, h });
            updateContainerHeight(top + h);
            return top;
        }

        function flyIn(img) {
            const rot = Number(img.dataset.origRot || 0);
            img.style.opacity = "1";
            img.style.transform = `translateY(0px) rotate(${rot}deg)`;
        }

        // queue for staggered animation
        let animationQueue = [];
        let animating = false;

        async function processAnimationQueue() {
            if (animating) return;
            animating = true;

            while (animationQueue.length > 0) {
                const img = animationQueue.shift();
                flyIn(img);
                await delay(delayMs);
            }

            animating = false;
        }

        function placeAndQueueAnimation(img) {
            currentY = layoutOne(img, currentY);
            animationQueue.push(img);
            processAnimationQueue();
        }

        async function initialLoad() {
            placed = [];
            currentY = 0;
            animationQueue = [];
            container.style.height = "0px";

            for (const img of imgs) {
                img.style.width = "";
                img.style.height = "";
                img.style.opacity = "0";
                img.style.transform = "translateY(40px)";
                img.dataset.zoomed = "0";
                // clear placement data so click handler knows it's not ready
                delete img.dataset.origW;
                delete img.dataset.origH;
                delete img.dataset.origLeft;
                delete img.dataset.origTop;
                delete img.dataset.origRot;
            }

            let loadedCount = 0;
            const total = imgs.length;

            return new Promise((resolveAll) => {
                for (const img of imgs) {
                    decodeOne(img).then(() => {
                        placeAndQueueAnimation(img);
                        loadedCount++;
                        if (loadedCount === total) {
                            initialLoadComplete = true;
                            initialWidth = container.clientWidth || 0;
                            resolveAll();
                        }
                    });
                }
            });
        }

        function relayout() {
            // don't relayout if an image is zoomed
            if (currentZoomed) {
                resetImg(currentZoomed);
                currentZoomed = null;
            }

            placed = [];
            currentY = 0;
            container.style.height = "0px";

            for (const img of imgs) {
                // skip images that haven't been placed yet
                if (!img.dataset.origW) continue;

                img.style.opacity = "0";
                img.style.transform = "translateY(40px)";
                img.dataset.zoomed = "0";
            }

            for (const img of imgs) {
                // skip images that haven't been placed yet
                if (!img.dataset.origW) continue;

                currentY = layoutOne(img, currentY);
                flyIn(img);
            }
        }

        let resizeTimer = 0;
        function relayoutOnResize() {
            if (!initialLoadComplete) return;

            const cw = container.clientWidth || 0;

            // only relayout on significant width change
            if (Math.abs(cw - initialWidth) < 10) return;

            initialWidth = cw;

            if (resizeTimer) {
                clearTimeout(resizeTimer);
            }
            resizeTimer = window.setTimeout(relayout, 150);
        }

        for (const img of imgs) {
            img.addEventListener("click", onPhotoClick);
        }

        initialLoad();
        window.addEventListener("resize", relayoutOnResize, { passive: true });
    }
</script>
