---
interface Props {
    images?: any[];
    maxSize?: number;
    delayMs?: number;
    rotationRange?: number;
}

const {
    images = [],
    maxSize = 400,
    delayMs = 300,
    rotationRange = 30,
} = Astro.props;

// randomize every render
const shuffled = [...images].sort(() => Math.random() - 0.5);
---

<div class="windowWidth">
    <div
        id="gallery"
        data-max={maxSize}
        data-delay={delayMs}
        data-rot={rotationRange}
    >
        {
            shuffled.map((u) => (
                <img
                    class="photo"
                    src={u.src}
                    alt="some image"
                    decoding="async"
                />
            ))
        }
    </div>
</div>

<style>
    .windowWidth {
        position: relative;
        width: 100vw;
        margin-left: calc(50% - 50vw);
        overflow: hidden;
        padding-top: 1000px;
        margin-top: -1000px;
    }

    #gallery {
        position: relative;
        margin: auto;
        width: 80%;
        margin-bottom: 20em;
    }

    .photo {
        position: absolute;
        display: block;
        transform-origin: 50% 50%;
        user-select: none;

        border-radius: 0.2em;
        box-shadow: 0 0 8px var(--color-shadow);

        /* start invisible + slightly shifted */
        opacity: 0;
        transform: translateY(40px);

        transition:
            opacity 0.6s ease,
            transform 0.6s ease,
            width 2s ease,
            height 2s ease,
            left 0.5s ease,
            top 0.5s ease;
    }
</style>

<script is:inline>
    const container = document.getElementById("gallery");
    if (!container) {
        // nothing to do
    } else {
        const maxSize = Number(container.dataset.max || 360);
        const delayMs = Number(container.dataset.delay || 180);
        const rotRange = Number(container.dataset.rot || 30);
        const imgs = Array.from(container.querySelectorAll("img"));
        let placed = [];
        let lastW = 0;
        let currentY = 0;
        let relayoutRunning = false;
        let currentZoomed = null;
        let initialLoadComplete = false;

        const triesPerImage = 60;
        const rand = (min, max) => Math.random() * (max - min) + min;

        function getUnitW() {
            const cw = container.clientWidth || 0;
            if (cw < 600) return maxSize * 0.4;
            if (cw < 900) return maxSize * 0.6;
            if (cw < 1200) return maxSize * 0.8;
            return maxSize;
        }

        function metrics() {
            const unitW = getUnitW();
            const bumpStep = unitW / 80;
            return { unitW, bumpStep };
        }

        function overlaps(a, b) {
            return !(
                a.x + a.w <= b.x ||
                b.x + b.w <= a.x ||
                a.y + a.h <= b.y ||
                b.y + b.h <= a.y
            );
        }

        function updateContainerHeight(bottom) {
            container.style.height = Math.ceil(bottom) + "px";
        }

        function resetImg(img) {
            const ow = Number(img.dataset.origW || 0);
            const oh = Number(img.dataset.origH || 0);
            const ol = Number(img.dataset.origLeft || 0);
            const ot = Number(img.dataset.origTop || 0);
            const rot = Number(img.dataset.origRot || 0);
            if (ow) img.style.width = ow + "px";
            if (oh) img.style.height = oh + "px";
            img.style.left = ol + "px";
            img.style.top = ot + "px";
            img.style.transform = `translateY(0px) rotate(${rot}deg)`;
            img.style.zIndex = "0";
            img.dataset.zoomed = "0";
        }

        function zoomImg(img) {
            const vw =
                window.innerWidth || document.documentElement.clientWidth || 0;
            const vh =
                window.innerHeight ||
                document.documentElement.clientHeight ||
                0;
            const origW = Number(img.dataset.origW || img.offsetWidth || 1);
            const origH = Number(img.dataset.origH || img.offsetHeight || 1);
            const maxScale = 3;
            const scale = Math.min(
                maxScale,
                (vw * 0.9) / origW,
                (vh * 0.9) / origH,
            );
            const targetW = origW * scale;
            const targetH = origH * scale;
            img.style.width = targetW + "px";
            img.style.height = targetH + "px";
            img.style.left = `calc(50% - ${targetW / 2}px)`;
            const scrollY = window.scrollY || window.pageYOffset || 0;
            const containerTop =
                container.getBoundingClientRect().top + scrollY;
            const centerTop = Math.max(
                0,
                scrollY + vh / 2 - targetH / 2 - containerTop,
            );
            img.style.top = centerTop + "px";
            img.style.transform = "rotate(0deg)";
            img.style.zIndex = "10";
            img.dataset.zoomed = "1";
        }

        function onPhotoClick(e) {
            const img = e.currentTarget;
            const isZoomed = img.dataset.zoomed === "1";
            if (isZoomed) {
                resetImg(img);
                currentZoomed = null;
                return;
            }
            if (currentZoomed && currentZoomed !== img) {
                resetImg(currentZoomed);
            }
            zoomImg(img);
            currentZoomed = img;
        }

        function decodeOne(img) {
            if (img.decode) {
                return img.decode().catch(() => {});
            }
            if (img.complete) return Promise.resolve();
            return new Promise((res) =>
                img.addEventListener("load", res, { once: true }),
            );
        }

        function delay(ms) {
            return new Promise((res) => setTimeout(res, ms));
        }

        function layoutOne(img, yStart) {
            const usableW = Math.max(0, container.clientWidth || 0);
            const { unitW, bumpStep } = metrics();
            const nw = img.naturalWidth || 1;
            const nh = img.naturalHeight || 1;
            let scale = Math.min(unitW / nw, unitW / nh, 1);
            scale *= rand(0.9, 1.1);
            const w = Math.round(nw * scale);
            const h = Math.round(nh * scale);
            let rot = rand(-rotRange, rotRange);
            if (!rot) rot = 3;
            let y = yStart;
            let x = 0;
            let ok = false;
            for (let attempt = 0; attempt < triesPerImage; attempt++) {
                const candX = rand(0, Math.max(0, usableW - w));
                const cand = { x: candX, y, w, h };
                ok = true;
                for (const p of placed) {
                    if (overlaps(cand, p)) {
                        ok = false;
                        break;
                    }
                }
                if (ok) {
                    x = candX;
                    break;
                }
                y += bumpStep;
            }
            if (!ok) {
                const maxX = Math.max(0, usableW - w);
                x = Math.max(0, Math.min(maxX, rand(0, maxX || 0)));
            }
            const left = Math.round(x);
            const top = Math.round(y);
            img.style.width = w + "px";
            img.style.height = h + "px";
            img.style.left = left + "px";
            img.style.top = top + "px";
            img.dataset.origW = String(w);
            img.dataset.origH = String(h);
            img.dataset.origLeft = String(left);
            img.dataset.origTop = String(top);
            img.dataset.origRot = String(rot);
            img.dataset.zoomed = "0";
            placed.push({ x: left, y: top, w, h });
            updateContainerHeight(top + h);
            return top;
        }

        function flyIn(img) {
            const rot = Number(img.dataset.origRot || 0);
            img.style.opacity = "1";
            img.style.transform = `translateY(0px) rotate(${rot}deg)`;
        }

        // queue for staggered animation
        let animationQueue = [];
        let animating = false;

        async function processAnimationQueue() {
            if (animating) return;
            animating = true;

            while (animationQueue.length > 0) {
                const img = animationQueue.shift();
                flyIn(img);
                await delay(delayMs);
            }

            animating = false;
        }

        function placeAndQueueAnimation(img) {
            currentY = layoutOne(img, currentY);
            animationQueue.push(img);
            processAnimationQueue();
        }

        async function initialLoad() {
            relayoutRunning = true;
            placed = [];
            currentY = 0;
            animationQueue = [];
            container.style.height = "0px";

            // reset all images to invisible
            for (const img of imgs) {
                img.style.width = "";
                img.style.height = "";
                img.style.opacity = "0";
                img.style.transform = "translateY(40px)";
                img.dataset.zoomed = "0";
            }

            // create a "race" - each image resolves independently when ready
            const pending = imgs.map((img, index) => {
                return decodeOne(img).then(() => ({ img, index }));
            });

            // as each image becomes ready, place it immediately
            let remaining = pending.length;

            while (remaining > 0) {
                // wait for the next image to be ready (whichever finishes first)
                const { img } = await Promise.race(
                    pending.filter((p) => (p instanceof Promise ? true : false))
                        .length > 0
                        ? pending
                        : [Promise.resolve(pending[0])],
                );

                // remove this one from pending by replacing with a never-resolving promise
                const idx = pending.findIndex(
                    (p) => p instanceof Promise === false || p === undefined,
                );
                if (idx === -1) {
                    // find and mark the resolved one
                    for (let i = 0; i < pending.length; i++) {
                        const result = await Promise.race([
                            pending[i],
                            Promise.resolve("still-pending"),
                        ]);
                        if (result !== "still-pending" && result.img === img) {
                            pending[i] = new Promise(() => {}); // never resolves
                            break;
                        }
                    }
                }

                placeAndQueueAnimation(img);
                remaining--;
            }

            initialLoadComplete = true;
            relayoutRunning = false;
        }

        // simpler approach - just track which are done
        async function initialLoadSimple() {
            relayoutRunning = true;
            placed = [];
            currentY = 0;
            animationQueue = [];
            container.style.height = "0px";

            for (const img of imgs) {
                img.style.width = "";
                img.style.height = "";
                img.style.opacity = "0";
                img.style.transform = "translateY(40px)";
                img.dataset.zoomed = "0";
            }

            const done = new Set();

            // start all decodes
            const promises = imgs.map((img) => {
                return decodeOne(img).then(() => img);
            });

            // process as they complete
            for (let i = 0; i < imgs.length; i++) {
                const readyImg = await Promise.race(
                    promises
                        .filter((_, idx) => !done.has(idx))
                        .map((p, filteredIdx) => {
                            // map back to original index
                            let originalIdx = -1;
                            let count = 0;
                            for (let j = 0; j < promises.length; j++) {
                                if (!done.has(j)) {
                                    if (count === filteredIdx) {
                                        originalIdx = j;
                                        break;
                                    }
                                    count++;
                                }
                            }
                            return p.then((img) => ({ img, originalIdx }));
                        }),
                );

                done.add(readyImg.originalIdx);
                placeAndQueueAnimation(readyImg.img);
            }

            initialLoadComplete = true;
            relayoutRunning = false;
        }

        // cleanest approach
        async function initialLoadClean() {
            relayoutRunning = true;
            placed = [];
            currentY = 0;
            animationQueue = [];
            container.style.height = "0px";

            for (const img of imgs) {
                img.style.width = "";
                img.style.height = "";
                img.style.opacity = "0";
                img.style.transform = "translateY(40px)";
                img.dataset.zoomed = "0";
            }

            // wrap each decode with its image reference
            let pending = imgs.map((img) => decodeOne(img).then(() => img));

            while (pending.length > 0) {
                // race all pending - first one ready wins
                const readyImg = await Promise.race(pending);

                // remove the winner from pending
                pending = pending.filter((p) => {
                    // check if this promise resolved to our image
                    // we need to re-wrap to check
                    return true; // can't easily check, so rebuild
                });

                // actually, rebuild pending excluding the ready one
                const readyIdx = imgs.indexOf(readyImg);
                pending = imgs
                    .filter(
                        (img, idx) => img !== readyImg && !img.dataset.placed,
                    )
                    .map((img) => decodeOne(img).then(() => img));

                readyImg.dataset.placed = "1";
                placeAndQueueAnimation(readyImg);
            }

            // cleanup
            for (const img of imgs) {
                delete img.dataset.placed;
            }

            initialLoadComplete = true;
            relayoutRunning = false;
        }

        // actually the cleanest - use a callback approach
        async function initialLoadFinal() {
            relayoutRunning = true;
            placed = [];
            currentY = 0;
            animationQueue = [];
            container.style.height = "0px";

            for (const img of imgs) {
                img.style.width = "";
                img.style.height = "";
                img.style.opacity = "0";
                img.style.transform = "translateY(40px)";
                img.dataset.zoomed = "0";
            }

            let loadedCount = 0;
            const total = imgs.length;

            return new Promise((resolveAll) => {
                for (const img of imgs) {
                    decodeOne(img).then(() => {
                        placeAndQueueAnimation(img);
                        loadedCount++;
                        if (loadedCount === total) {
                            initialLoadComplete = true;
                            relayoutRunning = false;
                            resolveAll();
                        }
                    });
                }
            });
        }

        async function relayout() {
            if (relayoutRunning) return;
            relayoutRunning = true;

            if (currentZoomed) {
                resetImg(currentZoomed);
                currentZoomed = null;
            }

            placed = [];
            currentY = 0;
            container.style.height = "0px";

            for (const img of imgs) {
                img.style.opacity = "0";
                img.style.transform = "translateY(40px)";
                img.dataset.zoomed = "0";
            }

            for (const img of imgs) {
                currentY = layoutOne(img, currentY);
                flyIn(img);
            }

            relayoutRunning = false;
        }

        let resizeTimer = 0;
        function relayoutOnResize() {
            if (!initialLoadComplete) return;
            const cw = container.clientWidth || 0;
            if (Math.abs(cw - lastW) < 2) return;
            lastW = cw;
            if (resizeTimer) {
                clearTimeout(resizeTimer);
            }
            resizeTimer = window.setTimeout(relayout, 150);
        }

        for (const img of imgs) {
            img.addEventListener("click", onPhotoClick);
        }

        initialLoadFinal();
        window.addEventListener("resize", relayoutOnResize, { passive: true });
    }
</script>
