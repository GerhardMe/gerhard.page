---
interface Props {
    images?: any[];
    maxSize?: number;
    delayMs?: number;
    rotationRange?: number;
}

const {
    images = [],
    maxSize = 400,
    delayMs = 150,
    rotationRange = 30,
} = Astro.props;
---

<style>
    .windowWidth {
        position: relative;
        width: 100vw;
        margin-left: calc(50% - 50vw);
    }

    #gallery {
        position: relative;
        margin: auto;
        width: 80%;
        margin-bottom: 20em;
    }

    .photo {
        position: absolute;
        display: block;
        will-change: transform, left, top, opacity;
        transform-origin: 50% 50%;
        user-select: none;

        border-radius: 0.2em;
        box-shadow: 0 0 8px var(--color-shadow);

        /* start invisible + slightly shifted */
        opacity: 0;
        transform: translateY(40px);

        transition:
            opacity 0.6s ease,
            transform 0.6s ease,
            width 2s ease,
            height 2s ease,
            left 0.5s ease,
            top 0.5s ease;

        overflow: hidden;
    }
</style>

<div class="windowWidth">
    <div
        id="gallery"
        data-max={maxSize}
        data-delay={delayMs}
        data-rot={rotationRange}
    >
        {
            images.map((u) => (
                <img
                    class="photo"
                    src={u.src}
                    alt="some image"
                    loading="eager"
                    decoding="async"
                />
            ))
        }
    </div>
</div>

<script is:inline>
    const container = document.getElementById("gallery");
    const maxSize = Number(container.dataset.max || 360);
    const delayMs = Number(container.dataset.delay || 180);
    const rotRange = Number(container.dataset.rot || 30);

    const imgs = Array.from(container.querySelectorAll("img"));
    let placed = []; // [{x,y,w,h}]
    let lastW = 0;
    let currentY = 0;

    /** ---------- sizing & metrics ---------- */
    function getUnitW() {
        const cw = container.clientWidth || 0;
        if (cw < 600) return maxSize * 0.4;
        if (cw < 900) return maxSize * 0.6;
        if (cw < 1200) return maxSize * 0.8;
        return maxSize;
    }
    function metrics() {
        const unitW = getUnitW();
        const bumpStep = unitW / 80; // nudge-down step during fit search
        return { unitW, bumpStep };
    }
    const triesPerImage = 100;
    const rand = (min, max) => Math.random() * (max - min) + min;

    function overlaps(a, b) {
        return !(
            a.x + a.w <= b.x ||
            b.x + b.w <= a.x ||
            a.y + a.h <= b.y ||
            b.y + b.h <= a.y
        );
    }

    function updateContainerHeight(bottom) {
        container.style.height = Math.ceil(bottom) + "px";
    }

    /** ---------- place ONE image ---------- */
    function layoutOne(img, yStart) {
        const usableW = Math.max(0, container.clientWidth || 0);
        const { unitW, bumpStep } = metrics();

        // scale image to unitW cap (both dims)
        const nw = img.naturalWidth || 1;
        const nh = img.naturalHeight || 1;
        let scale = Math.min(unitW / nw, unitW / nh, 1);
        scale *= rand(0.9, 1.1);
        const w = Math.round(nw * scale);
        const h = Math.round(nh * scale);

        let rot = rand(-rotRange, rotRange);
        if (rot === 0) {
            rot = 3;
        }

        // start at top, slide down until a free slot appears
        let y = yStart;
        let x = 0;
        let ok = false;

        for (let attempt = 0; attempt < triesPerImage; attempt++) {
            const candX = rand(0, Math.max(0, usableW - w));
            const cand = { x: candX, y, w, h };

            ok = true;
            for (const p of placed) {
                if (overlaps(cand, p)) {
                    ok = false;
                    break;
                }
            }
            if (ok) {
                x = candX;
                break;
            }
            y += bumpStep;
        }

        if (!ok) {
            // still no fit: drop somewhere at last y
            x = Math.max(0, Math.min(usableW - w, rand(0, usableW - w)));
        }

        img.style.width = w + "px";
        img.style.height = h + "px";
        img.style.left = Math.round(x) + "px";
        img.style.top = Math.round(y) + "px";
        img.addEventListener("click", scaleImg);

        placed.push({ x, y, w, h });
        updateContainerHeight(y + h);

        // fly-in animation: from opacity 0 + translateY(40px) to
        // opacity 1 + rotate(...)
        requestAnimationFrame(() => {
            img.style.opacity = "1";
            img.style.transform = `translateY(0px) rotate(${rot}deg)`;
        });

        return y;
    }

    /** ---------- place ALL images (with optional delay) ---------- */
    async function placeAll({ withDelay = true } = {}) {
        placed = [];
        container.style.height = "0px";

        // ensure clean start positions (avoid flash)
        for (const img of imgs) {
            img.style.width = "";
            img.style.height = "";
            img.style.left = "80vw";

            // reset animation state
            img.style.opacity = "0";
            img.style.transform = "translateY(40px)";
        }

        currentY = 0;

        for (let i = 0; i < imgs.length; i++) {
            const img = imgs[i];
            try {
                if (img.decode) {
                    await img.decode();
                } else {
                    await new Promise((res) =>
                        img.complete
                            ? res()
                            : img.addEventListener("load", res, { once: true }),
                    );
                }
            } catch {}

            currentY = layoutOne(img, currentY);

            if (withDelay && i < imgs.length - 1) {
                await new Promise((r) => setTimeout(r, delayMs));
            }
        }
    }

    /** ---------- resize handler (reuses the same placer, no delay) ---------- */
    let rAF = 0;
    function relayoutOnResize() {
        cancelAnimationFrame(rAF);
        rAF = requestAnimationFrame(async () => {
            const cw = container.clientWidth || 0;
            if (Math.abs(cw - lastW) < 2) return;
            lastW = cw;
            await placeAll({ withDelay: false });
        });
    }

    let scaled = false;
    let origLeft = "";
    let origRot = "";

    function scaleImg() {
        if (!scaled) {
            const h = parseInt(this.style.height, 10) || this.offsetHeight;
            const w = parseInt(this.style.width, 10) || this.offsetWidth;

            origLeft = this.style.left;
            origRot = this.style.transform;

            this.style.height = h * 3 + "px";
            this.style.width = w * 3 + "px";
            this.style.transform = "rotate(0deg)";
            this.style.zIndex = 1;

            this.style.left = `calc(50% - ${w * 1.5}px)`;

            scaled = true;
        } else if (this.style.transform === "rotate(0deg)") {
            const h = parseInt(this.style.height, 10) || this.offsetHeight;
            const w = parseInt(this.style.width, 10) || this.offsetWidth;

            this.style.height = h / 3 + "px";
            this.style.width = w / 3 + "px";
            this.style.left = origLeft;
            this.style.transform = origRot;

            scaled = false;

            setTimeout(() => (this.style.zIndex = 0), 2000);
        }
    }

    // initial run with delay (sequential fly-in)
    placeAll({ withDelay: true });
    window.addEventListener("resize", relayoutOnResize, { passive: true });
</script>
