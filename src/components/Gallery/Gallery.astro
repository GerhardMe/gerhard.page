---
interface Props {
    images?: any[];
    maxSize?: number;
    delayMs?: number;
    rotationRange?: number;
}

const {
    images = [],
    maxSize = 400,
    delayMs = 300,
    rotationRange = 30,
} = Astro.props;

// randomize every render
const shuffled = [...images].sort(() => Math.random() - 0.5);
---

<div class="windowWidth">
    <div
        id="gallery"
        data-max={maxSize}
        data-delay={delayMs}
        data-rot={rotationRange}
    >
        {
            shuffled.map((u) => (
                <img
                    class="photo"
                    src={u.src}
                    alt="some image"
                    decoding="async"
                />
            ))
        }
    </div>
</div>

<style>
    .windowWidth {
        position: relative;
        width: 100vw;
        margin-left: calc(50% - 50vw);
        overflow: hidden;
        padding-top: 1000px;
        margin-top: -1000px;
    }

    #gallery {
        position: relative;
        margin: auto;
        width: 80%;
        margin-bottom: 20em;
    }

    .photo {
        position: absolute;
        display: block;
        transform-origin: 50% 50%;
        user-select: none;

        border-radius: 0.2em;
        box-shadow: 0 0 8px var(--color-shadow);

        /* start invisible + slightly shifted */
        opacity: 0;
        transform: translateY(40px);

        transition:
            opacity 0.6s ease,
            transform 0.6s ease,
            width 2s ease,
            height 2s ease,
            left 0.5s ease,
            top 0.5s ease;
    }
</style>

<script is:inline>
    const container = document.getElementById("gallery");
    if (!container) {
        // nothing to do
    } else {
        const maxSize = Number(container.dataset.max || 360);
        const delayMs = Number(container.dataset.delay || 180);
        const rotRange = Number(container.dataset.rot || 30);

        const imgs = Array.from(container.querySelectorAll("img"));
        let placed = []; // [{x,y,w,h}]
        let lastW = 0;
        let currentY = 0;
        let relayoutRunning = false;
        let currentZoomed = null;
        let decodedOnce = false;

        /** ---------- utils ---------- */
        const triesPerImage = 60; // slightly reduced to lower work per image
        const rand = (min, max) => Math.random() * (max - min) + min;

        function getUnitW() {
            const cw = container.clientWidth || 0;
            if (cw < 600) return maxSize * 0.4;
            if (cw < 900) return maxSize * 0.6;
            if (cw < 1200) return maxSize * 0.8;
            return maxSize;
        }

        function metrics() {
            const unitW = getUnitW();
            const bumpStep = unitW / 80; // nudge-down step during fit search
            return { unitW, bumpStep };
        }

        function overlaps(a, b) {
            return !(
                a.x + a.w <= b.x ||
                b.x + b.w <= a.x ||
                a.y + a.h <= b.y ||
                b.y + b.h <= a.y
            );
        }

        function updateContainerHeight(bottom) {
            container.style.height = Math.ceil(bottom) + "px";
        }

        function resetImg(img) {
            const ow = Number(img.dataset.origW || 0);
            const oh = Number(img.dataset.origH || 0);
            const ol = Number(img.dataset.origLeft || 0);
            const ot = Number(img.dataset.origTop || 0);
            const rot = Number(img.dataset.origRot || 0);

            if (ow) img.style.width = ow + "px";
            if (oh) img.style.height = oh + "px";
            img.style.left = ol + "px";
            img.style.top = ot + "px";
            img.style.transform = `translateY(0px) rotate(${rot}deg)`;
            img.style.zIndex = "0";
            img.dataset.zoomed = "0";
        }

        function zoomImg(img) {
            const vw =
                window.innerWidth || document.documentElement.clientWidth || 0;
            const vh =
                window.innerHeight ||
                document.documentElement.clientHeight ||
                0;

            const origW = Number(img.dataset.origW || img.offsetWidth || 1);
            const origH = Number(img.dataset.origH || img.offsetHeight || 1);

            const maxScale = 3;
            const scale = Math.min(
                maxScale,
                (vw * 0.9) / origW,
                (vh * 0.9) / origH,
            );

            const targetW = origW * scale;
            const targetH = origH * scale;

            img.style.width = targetW + "px";
            img.style.height = targetH + "px";
            img.style.left = `calc(50% - ${targetW / 2}px)`;

            // center vertically in viewport, relative to container
            const scrollY = window.scrollY || window.pageYOffset || 0;
            const containerTop =
                container.getBoundingClientRect().top + scrollY;
            const centerTop = Math.max(
                0,
                scrollY + vh / 2 - targetH / 2 - containerTop,
            );
            img.style.top = centerTop + "px";

            img.style.transform = "rotate(0deg)";
            img.style.zIndex = "10";
            img.dataset.zoomed = "1";
        }

        function onPhotoClick(e) {
            const img = e.currentTarget;

            const isZoomed = img.dataset.zoomed === "1";

            if (isZoomed) {
                resetImg(img);
                currentZoomed = null;
                return;
            }

            if (currentZoomed && currentZoomed !== img) {
                resetImg(currentZoomed);
            }

            zoomImg(img);
            currentZoomed = img;
        }

        /** ---------- decode helpers (sequential) ---------- */
        function decodeOne(img) {
            if (img.decode) {
                return img.decode().catch(() => {
                    // ignore decode errors
                });
            }
            if (img.complete) return Promise.resolve();
            return new Promise((res) =>
                img.addEventListener("load", res, { once: true }),
            );
        }

        async function preloadAll() {
            if (decodedOnce) return;
            // decode sequentially to avoid a big Promise.all spike
            for (let i = 0; i < imgs.length; i++) {
                const img = imgs[i];
                // small yield between decodes for responsiveness
                await decodeOne(img);
            }
            decodedOnce = true;
        }

        /** ---------- layout of ONE image (no animation) ---------- */
        function layoutOne(img, yStart) {
            const usableW = Math.max(0, container.clientWidth || 0);
            const { unitW, bumpStep } = metrics();

            const nw = img.naturalWidth || 1;
            const nh = img.naturalHeight || 1;
            let scale = Math.min(unitW / nw, unitW / nh, 1);
            scale *= rand(0.9, 1.1);
            const w = Math.round(nw * scale);
            const h = Math.round(nh * scale);

            let rot = rand(-rotRange, rotRange);
            if (!rot) rot = 3;

            let y = yStart;
            let x = 0;
            let ok = false;

            for (let attempt = 0; attempt < triesPerImage; attempt++) {
                const candX = rand(0, Math.max(0, usableW - w));
                const cand = { x: candX, y, w, h };

                ok = true;
                for (const p of placed) {
                    if (overlaps(cand, p)) {
                        ok = false;
                        break;
                    }
                }
                if (ok) {
                    x = candX;
                    break;
                }
                y += bumpStep;
            }

            if (!ok) {
                const maxX = Math.max(0, usableW - w);
                x = Math.max(0, Math.min(maxX, rand(0, maxX || 0)));
            }

            const left = Math.round(x);
            const top = Math.round(y);

            img.style.width = w + "px";
            img.style.height = h + "px";
            img.style.left = left + "px";
            img.style.top = top + "px";

            img.dataset.origW = String(w);
            img.dataset.origH = String(h);
            img.dataset.origLeft = String(left);
            img.dataset.origTop = String(top);
            img.dataset.origRot = String(rot);
            img.dataset.zoomed = img.dataset.zoomed || "0";

            placed.push({ x: left, y: top, w, h });
            updateContainerHeight(y + h);

            // keep invisible and shifted for fly-in; no animation here
            img.style.opacity = "0";
            img.style.transform = `translateY(40px) rotate(${rot}deg)`;

            return y;
        }

        /** ---------- animate all (after layout) ---------- */
        function delay(ms) {
            return new Promise((res) => setTimeout(res, ms));
        }

        function nextFrame() {
            return new Promise((res) => requestAnimationFrame(res));
        }

        async function flyInAll(withDelay) {
            if (!withDelay) {
                for (const img of imgs) {
                    const rot = Number(img.dataset.origRot || 0);
                    img.style.opacity = "1";
                    img.style.transform = `translateY(0px) rotate(${rot}deg)`;
                }
                return;
            }

            for (let i = 0; i < imgs.length; i++) {
                const img = imgs[i];
                const rot = Number(img.dataset.origRot || 0);
                img.style.opacity = "1";
                img.style.transform = `translateY(0px) rotate(${rot}deg)`;
                if (i < imgs.length - 1) {
                    await delay(delayMs);
                }
            }
        }

        /** ---------- place ALL images (incremental) ---------- */
        async function placeAll({ withDelay = true, fromResize = false } = {}) {
            if (fromResize && relayoutRunning) return;
            relayoutRunning = true;

            try {
                await preloadAll();

                // close any zoom before relayout
                if (currentZoomed) {
                    resetImg(currentZoomed);
                    currentZoomed = null;
                }

                placed = [];
                container.style.height = "0px";

                for (const img of imgs) {
                    img.style.width = "";
                    img.style.height = "";
                    img.style.opacity = "0";
                    img.style.transform = "translateY(40px)";
                    img.dataset.zoomed = "0";
                }

                currentY = 0;

                // place images one-by-one, yielding every few to reduce spikes
                const batchSize = 3;
                for (let i = 0; i < imgs.length; i++) {
                    const img = imgs[i];
                    currentY = layoutOne(img, currentY);
                    if ((i + 1) % batchSize === 0) {
                        await nextFrame();
                    }
                }

                await flyInAll(withDelay);
            } finally {
                relayoutRunning = false;
            }
        }

        /** ---------- resize handler (debounced, no decode) ---------- */
        let resizeTimer = 0;
        function relayoutOnResize() {
            const cw = container.clientWidth || 0;
            if (Math.abs(cw - lastW) < 2) return;
            lastW = cw;

            if (resizeTimer) {
                clearTimeout(resizeTimer);
            }
            resizeTimer = window.setTimeout(() => {
                placeAll({ withDelay: false, fromResize: true });
            }, 150);
        }

        // attach listeners once
        for (const img of imgs) {
            img.addEventListener("click", onPhotoClick);
        }

        // initial run: preload all, then layout+fly-in
        setTimeout(() => {
            placeAll({ withDelay: true, fromResize: false });
        }, 200);

        window.addEventListener("resize", relayoutOnResize, { passive: true });
    }
</script>
