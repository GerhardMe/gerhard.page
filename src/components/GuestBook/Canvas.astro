---

---

<div class="canvas-wrapper" id="canvas-wrapper">
  <canvas id="guestbook-canvas"></canvas>
  <canvas id="drawing-canvas"></canvas>
</div>

<style>
  .canvas-wrapper {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1.4142;
  }

  #guestbook-canvas,
  #drawing-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  #guestbook-canvas {
    background: #fcfaf6;
    box-shadow: 0 0 8px var(--color-shadow);
  }

  #drawing-canvas {
    cursor: crosshair;
  }

  #drawing-canvas.text-mode {
    cursor: text;
  }
</style>

<script>
  import {
    initDrawing,
    setBrushSize as setDrawingBrushSize,
    drawStroke,
  } from "./drawing";
  import {
    initTextbox,
    createTextbox,
    hasActiveTextbox,
    confirmTextbox,
    setFontSize as setTextboxFontSize,
    drawTextAction,
  } from "./textbox";
  import { state, subscribe, clearActions } from "./state";

  const API_URL = "/api/guestbook";

  const canvasWrapper = document.getElementById("canvas-wrapper")!;
  const guestbookCanvas = document.getElementById(
    "guestbook-canvas"
  ) as HTMLCanvasElement;
  const drawingCanvas = document.getElementById(
    "drawing-canvas"
  ) as HTMLCanvasElement;

  const guestbookCtx = guestbookCanvas.getContext("2d")!;
  const drawingCtx = drawingCanvas.getContext("2d")!;

  // Store contexts in state for controls to access
  state.drawingCtx = drawingCtx;
  state.guestbookCtx = guestbookCtx;

  function getCanvasCoords(e: MouseEvent | Touch): { x: number; y: number } {
    const rect = drawingCanvas.getBoundingClientRect();
    const scaleX = state.canvasWidth / rect.width;
    const scaleY = state.canvasHeight / rect.height;

    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY,
    };
  }

  function initCanvases() {
    guestbookCanvas.width = state.canvasWidth;
    guestbookCanvas.height = state.canvasHeight;
    drawingCanvas.width = state.canvasWidth;
    drawingCanvas.height = state.canvasHeight;

    initDrawing(drawingCanvas, drawingCtx, getCanvasCoords);
    initTextbox(
      canvasWrapper,
      drawingCtx,
      getCanvasCoords,
      state.canvasWidth,
      state.canvasHeight
    );

    // Sync initial state
    setDrawingBrushSize(state.brushSize);
    setTextboxFontSize(state.fontSize);
    (window as any).guestbookMode = state.mode;

    loadGuestbook();
  }

  async function loadGuestbook() {
    // Clear the guestbook canvas with paper color
    guestbookCtx.fillStyle = "#fcfaf6";
    guestbookCtx.fillRect(0, 0, guestbookCanvas.width, guestbookCanvas.height);

    try {
      const response = await fetch(`${API_URL}?page=${state.currentPage}`);
      if (response.ok) {
        const blob = await response.blob();
        const img = new Image();
        img.onload = () => {
          // Draw the pre-colorized image from backend
          guestbookCtx.drawImage(
            img,
            0,
            0,
            guestbookCanvas.width,
            guestbookCanvas.height
          );
        };
        img.src = URL.createObjectURL(blob);
      }
    } catch (e) {
      console.log("No existing guestbook page yet");
    }
  }

  // Redraw all actions (used after undo)
  function redrawActions() {
    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    for (const action of state.actions) {
      if (action.type === "stroke") {
        drawStroke(action);
      } else if (action.type === "text") {
        drawTextAction(action);
      }
    }
  }

  // React to state changes
  subscribe(() => {
    drawingCanvas.classList.toggle("text-mode", state.mode === "text");
    setDrawingBrushSize(state.brushSize);
    setTextboxFontSize(state.fontSize);
  });

  // Text mode handlers
  // Track if we just handled a touch to prevent duplicate click
  let handledByTouch = false;

  // Mouse click handler
  drawingCanvas.addEventListener("click", (e) => {
    if (handledByTouch) {
      handledByTouch = false;
      return;
    }
    if (state.mode === "text") {
      if (hasActiveTextbox()) {
        confirmTextbox();
      } else {
        createTextbox(e);
      }
    }
  });

  // Touch handler - track touch count and movement
  let touchCount = 0;
  let touchStartX = 0;
  let touchStartY = 0;
  let touchMoved = false;
  const MOVE_THRESHOLD = 10; // pixels

  drawingCanvas.addEventListener(
    "touchstart",
    (e) => {
      touchCount = e.touches.length;
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchMoved = false;
      }
    },
    { passive: true }
  );

  drawingCanvas.addEventListener(
    "touchmove",
    (e) => {
      if (e.touches.length === 1 && !touchMoved) {
        const dx = e.touches[0].clientX - touchStartX;
        const dy = e.touches[0].clientY - touchStartY;
        if (Math.abs(dx) > MOVE_THRESHOLD || Math.abs(dy) > MOVE_THRESHOLD) {
          touchMoved = true;
        }
      }
    },
    { passive: true }
  );

  drawingCanvas.addEventListener("touchend", (e) => {
    // Don't create textbox if multi-touch or dragged
    if (touchCount > 1 || touchMoved) {
      touchCount = e.touches.length;
      return;
    }
    touchCount = e.touches.length;

    if (state.mode === "text") {
      handledByTouch = true;
      if (hasActiveTextbox()) {
        confirmTextbox();
      } else {
        e.preventDefault();
        createTextbox(e.changedTouches[0]);
      }
    }
  });

  // Expose functions for controls
  (window as any).guestbook = {
    loadGuestbook,
    clearDrawing: () => {
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      clearActions();
    },
    getImageData: () => drawingCanvas.toDataURL("image/png"),
    confirmTextbox,
    hasActiveTextbox,
    redrawActions,
  };

  initCanvases();
</script>
