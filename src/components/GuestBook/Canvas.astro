---

---

<div class="canvas-wrapper hidden" id="canvas-wrapper">
  <canvas id="guestbook-canvas"></canvas>
  <canvas id="drawing-canvas"></canvas>
</div>

<style>
  .canvas-wrapper {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1.4142;
  }

  .canvas-wrapper.hidden {
    visibility: hidden;
  }

  #guestbook-canvas,
  #drawing-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  #guestbook-canvas {
    background: #fcfaf6;
    box-shadow: 0 0 8px var(--color-shadow);
  }

  #drawing-canvas {
    cursor: crosshair;
  }

  #drawing-canvas.text-mode {
    cursor: text;
  }
</style>

<script>
  import {
    initDrawing,
    setBrushSize as setDrawingBrushSize,
    drawStroke,
  } from "./drawing";
  import {
    initTextbox,
    createTextbox,
    hasActiveTextbox,
    confirmTextbox,
    setFontSize as setTextboxFontSize,
    drawTextAction,
  } from "./textbox";
  import { state, subscribe, clearActions, setStatus, setTotalPages } from "./state";

  const API_URL = "/api/guestbook";

  const canvasWrapper = document.getElementById("canvas-wrapper")!;
  const guestbookCanvas = document.getElementById(
    "guestbook-canvas"
  ) as HTMLCanvasElement;
  const drawingCanvas = document.getElementById(
    "drawing-canvas"
  ) as HTMLCanvasElement;

  const guestbookCtx = guestbookCanvas.getContext("2d")!;
  const drawingCtx = drawingCanvas.getContext("2d")!;

  // Store contexts in state for controls to access
  state.drawingCtx = drawingCtx;
  state.guestbookCtx = guestbookCtx;

  function getCanvasCoords(e: MouseEvent | Touch): { x: number; y: number } {
    const rect = drawingCanvas.getBoundingClientRect();
    const scaleX = state.canvasWidth / rect.width;
    const scaleY = state.canvasHeight / rect.height;

    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY,
    };
  }

  async function initCanvases() {
    guestbookCanvas.width = state.canvasWidth;
    guestbookCanvas.height = state.canvasHeight;
    drawingCanvas.width = state.canvasWidth;
    drawingCanvas.height = state.canvasHeight;

    initDrawing(drawingCanvas, drawingCtx, getCanvasCoords);
    initTextbox(
      canvasWrapper,
      drawingCtx,
      getCanvasCoords,
      state.canvasWidth,
      state.canvasHeight
    );

    // Sync initial state
    setDrawingBrushSize(state.brushSize);
    setTextboxFontSize(state.fontSize);
    (window as any).guestbookMode = state.mode;

    // Fetch page count first, then load guestbook
    await fetchPageCount();
    await loadGuestbook();
  }

  const FETCH_TIMEOUT = 15000; // 15 seconds

  async function fetchPageCount() {
    try {
      const response = await fetch(`${API_URL}?action=info`);
      if (response.ok) {
        const data = await response.json();
        setTotalPages(data.pages || 1);
      }
    } catch (e) {
      console.error("Failed to fetch page count:", e);
    }
  }

  async function loadGuestbook() {
    setStatus({ type: "fetching" });

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

      const response = await fetch(`${API_URL}?page=${state.currentPage}`, {
        signal: controller.signal,
      });
      clearTimeout(timeoutId);

      if (response.ok) {
        const blob = await response.blob();
        const img = new Image();

        await new Promise<void>((resolve, reject) => {
          img.onload = () => {
            // Clear and draw in one go - no flicker
            guestbookCtx.fillStyle = "#fcfaf6";
            guestbookCtx.fillRect(0, 0, guestbookCanvas.width, guestbookCanvas.height);
            guestbookCtx.drawImage(
              img,
              0,
              0,
              guestbookCanvas.width,
              guestbookCanvas.height
            );
            // Reveal canvas on first load
            canvasWrapper.classList.remove("hidden");
            resolve();
          };
          img.onerror = reject;
          img.src = URL.createObjectURL(blob);
        });

        setStatus({ type: "ready" });
      } else {
        throw new Error("Server error");
      }
    } catch (e) {
      if (e instanceof Error && e.name === "AbortError") {
        setStatus({ type: "error", message: "Timeout - try again" });
      } else {
        setStatus({ type: "error", message: "Failed to load" });
      }
      console.error("Error loading guestbook:", e);
      // Auto-recover to ready state after showing error
      setTimeout(() => {
        if (state.status.type === "error") {
          setStatus({ type: "ready" });
        }
      }, 3000);
    }
  }

  // Redraw all actions (used after undo)
  function redrawActions() {
    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    for (const action of state.actions) {
      if (action.type === "stroke") {
        drawStroke(action);
      } else if (action.type === "text") {
        drawTextAction(action);
      }
    }
  }

  // React to state changes
  subscribe(() => {
    drawingCanvas.classList.toggle("text-mode", state.mode === "text");
    setDrawingBrushSize(state.brushSize);
    setTextboxFontSize(state.fontSize);
  });

  // Text mode handlers
  // Track if we just handled a touch to prevent duplicate click
  let handledByTouch = false;

  // Mouse click handler
  drawingCanvas.addEventListener("click", (e) => {
    if (handledByTouch) {
      handledByTouch = false;
      return;
    }
    if (state.mode === "text") {
      if (hasActiveTextbox()) {
        confirmTextbox();
      } else {
        createTextbox(e);
      }
    }
  });

  // Touch handler - track touch count and movement
  let touchCount = 0;
  let touchStartX = 0;
  let touchStartY = 0;
  let touchMoved = false;
  const MOVE_THRESHOLD = 10; // pixels

  drawingCanvas.addEventListener(
    "touchstart",
    (e) => {
      touchCount = e.touches.length;
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchMoved = false;
      }
    },
    { passive: true }
  );

  drawingCanvas.addEventListener(
    "touchmove",
    (e) => {
      if (e.touches.length === 1 && !touchMoved) {
        const dx = e.touches[0].clientX - touchStartX;
        const dy = e.touches[0].clientY - touchStartY;
        if (Math.abs(dx) > MOVE_THRESHOLD || Math.abs(dy) > MOVE_THRESHOLD) {
          touchMoved = true;
        }
      }
    },
    { passive: true }
  );

  drawingCanvas.addEventListener("touchend", (e) => {
    // Don't create textbox if multi-touch or dragged
    if (touchCount > 1 || touchMoved) {
      touchCount = e.touches.length;
      return;
    }
    touchCount = e.touches.length;

    if (state.mode === "text") {
      handledByTouch = true;
      if (hasActiveTextbox()) {
        confirmTextbox();
      } else {
        e.preventDefault();
        createTextbox(e.changedTouches[0]);
      }
    }
  });

  // Expose functions for controls
  (window as any).guestbook = {
    loadGuestbook,
    fetchPageCount,
    clearDrawing: () => {
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      clearActions();
    },
    getImageData: () => drawingCanvas.toDataURL("image/png"),
    confirmTextbox,
    hasActiveTextbox,
    redrawActions,
  };

  initCanvases();
</script>
