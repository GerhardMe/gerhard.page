---
import ControlBar from "./ControlBar.astro";

interface Props {
  position: "top" | "bottom";
}

const { position } = Astro.props;
---

<div class:list={["controls-bar", position]}>
  <ControlBar />
</div>


<style>
  .controls-bar {
    display: flex;
    flex-direction: column;
    gap: 0.5em;
  }

  .controls-bar.top {
    margin-bottom: 1em;
  }

  .controls-bar.bottom {
    margin-top: 1em;
  }
</style>

<script>
  import {
    state,
    subscribe,
    setMode,
    setBrushSize,
    setFontSize,
    setStatus,
    setTotalPages,
    undo,
    nextPage,
    prevPage,
    clearActions,
    totalPages,
  } from "./state";

  const API_URL = "/api/guestbook";

  // Only run setup once (top instance)
  if (!(window as any).__controlsInitialized) {
    (window as any).__controlsInitialized = true;

    function setupControls() {
      const drawModeBtns =
        document.querySelectorAll<HTMLButtonElement>(".draw-mode");
      const textModeBtns =
        document.querySelectorAll<HTMLButtonElement>(".text-mode");
      const brushSliders =
        document.querySelectorAll<HTMLInputElement>(".brush-slider");
      const brushValues =
        document.querySelectorAll<HTMLSpanElement>(".brush-value");
      const fontSliders =
        document.querySelectorAll<HTMLInputElement>(".font-slider");
      const fontValues =
        document.querySelectorAll<HTMLSpanElement>(".font-value");
      const undoBtns =
        document.querySelectorAll<HTMLButtonElement>(".undo-btn");
      const submitBtns =
        document.querySelectorAll<HTMLButtonElement>(".submit-btn");
      const prevBtns =
        document.querySelectorAll<HTMLButtonElement>(".prev-page");
      const nextBtns =
        document.querySelectorAll<HTMLButtonElement>(".next-page");
      const pageIndicators =
        document.querySelectorAll<HTMLSpanElement>(".page-indicator");

      function getStatusText(): string {
        switch (state.status.type) {
          case "initializing":
            return "Initializing...";
          case "fetching":
            return "Fetching guestbook...";
          case "sending":
            return "Sending update...";
          case "error":
            return state.status.message;
          case "ready":
            return `${state.currentPage} / ${totalPages}`;
        }
      }

      function updateUI() {
        drawModeBtns.forEach((btn) =>
          btn.classList.toggle("active", state.mode === "draw")
        );
        textModeBtns.forEach((btn) =>
          btn.classList.toggle("active", state.mode === "text")
        );
        brushSliders.forEach(
          (slider) => (slider.value = String(state.brushSize))
        );
        brushValues.forEach(
          (span) => (span.textContent = `${state.brushSize}px`)
        );
        fontSliders.forEach(
          (slider) => (slider.value = String(state.fontSize))
        );
        fontValues.forEach(
          (span) => (span.textContent = `${state.fontSize}pt`)
        );
        pageIndicators.forEach(
          (span) => (span.textContent = getStatusText())
        );
        // Disable nav during loading/sending
        const isLoading = state.status.type === "fetching" || state.status.type === "sending";
        prevBtns.forEach((btn) => (btn.disabled = state.currentPage <= 1 || isLoading));
        nextBtns.forEach(
          (btn) => (btn.disabled = state.currentPage >= totalPages || isLoading)
        );
      }

      subscribe(updateUI);

      // Mode switching
      drawModeBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          const gb = (window as any).guestbook;
          if (gb?.hasActiveTextbox()) {
            gb.confirmTextbox();
          }
          setMode("draw");
        });
      });

      textModeBtns.forEach((btn) => {
        btn.addEventListener("click", () => setMode("text"));
      });

      // Brush size sliders
      brushSliders.forEach((slider) => {
        slider.addEventListener("input", () => {
          setBrushSize(parseInt(slider.value, 10));
          setMode("draw");
        });
      });

      // Font size sliders
      fontSliders.forEach((slider) => {
        slider.addEventListener("input", () => {
          setFontSize(parseInt(slider.value, 10));
          setMode("text");
        });
      });

      // Undo
      undoBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          const action = undo();
          if (action) {
            const gb = (window as any).guestbook;
            gb?.redrawActions();
          }
        });
      });

      // Pagination
      prevBtns.forEach((btn) => {
        btn.addEventListener("click", async () => {
          const gb = (window as any).guestbook;
          if (gb?.hasActiveTextbox()) {
            gb.confirmTextbox();
          }
          prevPage();
          gb?.redrawActions();
          await gb?.loadGuestbook();
        });
      });

      nextBtns.forEach((btn) => {
        btn.addEventListener("click", async () => {
          const gb = (window as any).guestbook;
          if (gb?.hasActiveTextbox()) {
            gb.confirmTextbox();
          }
          nextPage();
          gb?.redrawActions();
          await gb?.loadGuestbook();
        });
      });

      // Submit - sends only current page
      submitBtns.forEach((btn) => {
        btn.addEventListener("click", async () => {
          const gb = (window as any).guestbook;

          if (gb?.hasActiveTextbox()) {
            gb.confirmTextbox();
          }

          // Check if there's anything to send on current page
          if (state.actions.length === 0) {
            setStatus({ type: "error", message: "Nothing to send" });
            setTimeout(() => setStatus({ type: "ready" }), 2000);
            return;
          }

          setStatus({ type: "sending" });

          const imageData = gb?.getImageData();

          try {
            const response = await fetch(API_URL, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                image: imageData,
                page: state.currentPage,
              }),
            });

            if (response.ok) {
              // Reload guestbook first (keeps drawing visible during load)
              await gb?.loadGuestbook();
              // Refresh page count (new page may be available)
              await gb?.fetchPageCount();
              // Then clear the drawing layer
              clearActions();
              gb?.redrawActions();
            } else {
              throw new Error("Server error");
            }
          } catch (e) {
            setStatus({ type: "error", message: "Error submitting" });
            setTimeout(() => setStatus({ type: "ready" }), 3000);
          }
        });
      });

      updateUI();
    }

    // Run after DOM is ready
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", setupControls);
    } else {
      setupControls();
    }
  }
</script>
