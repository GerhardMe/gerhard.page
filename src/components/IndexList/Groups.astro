---
import DefaultList from "./Lists/Books.astro";
import GroupButtons from "./GroupsBtn.astro";

interface Props {
    media: any[];
    groupBy?: string[];
    favorites?: boolean;
    List?: any;
}

const {
    media,
    groupBy = ["time"],
    favorites = false,
    List = DefaultList,
} = Astro.props;

function fm(post: any) {
    return post.frontmatter ?? post.data ?? {};
}

function cmp(a: any, b: any) {
    const da = new Date(fm(a).date ?? 0).getTime();
    const db = new Date(fm(b).date ?? 0).getTime();
    return db - da; // newest first
}

// Special handling for "time"
const timeFirst = groupBy[0] === "time";
const otherKeys = groupBy.filter((k) => k !== "time");

// Flat, date-sorted list
const sortedAllDesc = [...media].sort(cmp);
const sortedAllAsc = [...sortedAllDesc].slice().reverse();

function buildBuckets(key: string) {
    const buckets = new Map<string, any[]>();

    for (const post of media) {
        const f = fm(post);
        const raw = f[key];
        const k = raw == null || raw === "" ? `No ${key}` : String(raw);
        if (!buckets.has(k)) buckets.set(k, []);
        buckets.get(k)!.push(post);
    }

    // sort posts inside each bucket (desc by time)
    for (const [, arr] of buckets) arr.sort(cmp);

    // numeric groups high→low, else alpha
    const groupsDesc = Array.from(buckets.keys()).sort((a, b) => {
        const na = Number(a);
        const nb = Number(b);
        const aIsNum = !Number.isNaN(na);
        const bIsNum = !Number.isNaN(nb);
        if (aIsNum && bIsNum) return nb - na;
        return a.toLowerCase().localeCompare(b.toLowerCase());
    });

    return { groupsDesc, buckets };
}

// Precompute grouped sets for non-time keys only
const prebuilt = otherKeys.map((k) => ({ key: k, ...buildBuckets(k) }));

// Favorites (optional)
const favoritesList = favorites ? media.filter((p) => !!fm(p).favorite) : [];
---

{
    favorites && favoritesList.length > 0 && (
        <List posts={favoritesList} title="My all time favorites:" />
    )
}

<GroupButtons keys={groupBy} />

<!-- TIME: desc -->
<section
    class={`groupset ${timeFirst ? "" : "hidden"}`}
    data-key="time"
    data-order="desc"
>
    <List posts={sortedAllDesc} />
</section>

<!-- TIME: asc -->
<section class="groupset hidden" data-key="time" data-order="asc">
    <List posts={sortedAllAsc} />
</section>

<!-- Grouped sections for the other keys -->
{
    prebuilt.flatMap(({ key, groupsDesc, buckets }, i) => {
        const isFirstNonTime = !timeFirst && i === 0;

        const descSection = (
            <section
                class={`groupset ${isFirstNonTime ? "" : "hidden"}`}
                data-key={key}
                data-order="desc"
            >
                {groupsDesc.map((g) => {
                    const list = buckets.get(g) ?? [];
                    if (list.length === 0) return null;
                    return <List posts={list} title={g} />;
                })}
            </section>
        );

        const ascSection = (
            <section class="groupset hidden" data-key={key} data-order="asc">
                {[...groupsDesc].reverse().map((g) => {
                    const listDesc = buckets.get(g) ?? [];
                    if (listDesc.length === 0) return null;
                    const listAsc = [...listDesc].reverse();
                    return <List posts={listAsc} title={g} />;
                })}
            </section>
        );

        return [descSection, ascSection];
    })
}

<style>
    .hidden {
        display: none;
    }
</style>

<script is:inline>
    (function () {
        let currentKey = "time";
        let currentOrder = "desc";

        document.addEventListener("groupby-change", (e) => {
            const key = e.detail?.key;
            if (!key) return;

            // same key → flip order, new key → reset to desc
            const order =
                key === currentKey && currentOrder === "desc" ? "asc" : "desc";

            currentKey = key;
            currentOrder = order;

            document.querySelectorAll(".groupset").forEach((s) => {
                const match =
                    s.dataset.key === key && s.dataset.order === order;
                s.classList.toggle("hidden", !match);
            });
        });
    })();
</script>
