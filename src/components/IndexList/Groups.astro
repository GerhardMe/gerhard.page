---
import DefaultList from "./Lists/Books.astro";
import GroupButtons from "./GroupsBtn.astro";

interface __Props__ {
    media: any[];
    groupBy?: string[];
    favorites?: boolean;
    List?: any;
}

const {
    media,
    groupBy = ["read"],
    favorites = false,
    List = DefaultList,
} = Astro.props;

function fm(post: any) {
    return post.frontmatter ?? post.data ?? {};
}

function isDateValue(val: any) {
    if (val == null || val === "") return false;
    // Numbers alone shouldn't count as dates (years, ratings, etc.)
    if (typeof val === "number") return false;
    // Must be a string that looks like a date
    if (typeof val !== "string") return false;
    // Reject short strings (like "4" or "1957")
    if (val.length < 6) return false;
    const d = new Date(val);
    return !isNaN(d.getTime());
}

function isDateKey(key: string) {
    const samples = media.slice(0, 10);
    const validDates = samples.filter((p) => isDateValue(fm(p)[key]));
    return validDates.length > samples.length / 2;
}

const dateKeys = groupBy.filter(isDateKey);
const bucketKeys = groupBy.filter((k) => !isDateKey(k));

function buildDateSections(key: string) {
    const sorted = [...media].sort((a, b) => {
        const da = new Date(fm(a)[key] ?? 0).getTime() || 0;
        const db = new Date(fm(b)[key] ?? 0).getTime() || 0;
        return db - da;
    });
    return { desc: sorted, asc: [...sorted].reverse() };
}

function buildBuckets(key: string) {
    const buckets = new Map<string, any[]>();
    for (const post of media) {
        const f = fm(post);
        const raw = f[key];
        const k = raw == null || raw === "" ? `No ${key}` : String(raw);
        if (!buckets.has(k)) buckets.set(k, []);
        buckets.get(k)!.push(post);
    }

    // sort posts inside each bucket by first date key, or keep original order
    const sortKey = dateKeys[0];
    if (sortKey) {
        for (const [, arr] of buckets) {
            arr.sort((a, b) => {
                const da = new Date(fm(a)[sortKey] ?? 0).getTime() || 0;
                const db = new Date(fm(b)[sortKey] ?? 0).getTime() || 0;
                return db - da;
            });
        }
    }

    const groupsDesc = Array.from(buckets.keys()).sort((a, b) => {
        const na = Number(a);
        const nb = Number(b);
        if (!Number.isNaN(na) && !Number.isNaN(nb)) return nb - na;
        return a.toLowerCase().localeCompare(b.toLowerCase());
    });

    return { groupsDesc, buckets };
}

const dateSections = Object.fromEntries(
    dateKeys.map((k) => [k, buildDateSections(k)]),
);

const prebuilt = bucketKeys.map((k) => ({ key: k, ...buildBuckets(k) }));

const favoritesList = favorites ? media.filter((p) => !!fm(p).favorite) : [];

// Figure out which key/order shows first
const firstKey = groupBy[0];
const firstIsDate = dateKeys.includes(firstKey);
---

{
    favorites && favoritesList.length > 0 && (
        <List posts={favoritesList} title="My all time favorites:" />
    )
}

<GroupButtons keys={groupBy} />

<!-- Date-based keys -->
{
    dateKeys.map((key) => {
        const isFirst = key === firstKey;
        return [
            <section
                class={`groupset ${isFirst ? "" : "hidden"}`}
                data-key={key}
                data-order="desc"
            >
                <List posts={dateSections[key].desc} />
            </section>,
            <section class="groupset hidden" data-key={key} data-order="asc">
                <List posts={dateSections[key].asc} />
            </section>,
        ];
    })
}

<!-- Bucketed keys -->
{
    prebuilt.flatMap(({ key, groupsDesc, buckets }) => {
        const isFirst = key === firstKey;
        return [
            <section
                class={`groupset ${isFirst ? "" : "hidden"}`}
                data-key={key}
                data-order="desc"
            >
                {groupsDesc.map((g) => {
                    const list = buckets.get(g) ?? [];
                    if (list.length === 0) return null;
                    return <List posts={list} title={g} />;
                })}
            </section>,
            <section class="groupset hidden" data-key={key} data-order="asc">
                {[...groupsDesc].reverse().map((g) => {
                    const listDesc = buckets.get(g) ?? [];
                    if (listDesc.length === 0) return null;
                    return <List posts={listDesc} title={g} />;
                })}
            </section>,
        ];
    })
}

<style>
    .hidden {
        display: none;
    }
</style>

<script is:inline>
    (function () {
        let currentKey =
            document.querySelector(".groupset:not(.hidden)")?.dataset.key ?? "";
        let currentOrder = "desc";

        document.addEventListener("groupby-change", (e) => {
            const key = e.detail?.key;
            if (!key) return;

            const order =
                key === currentKey && currentOrder === "desc" ? "asc" : "desc";
            currentKey = key;
            currentOrder = order;

            document.querySelectorAll(".groupset").forEach((s) => {
                const match =
                    s.dataset.key === key && s.dataset.order === order;
                s.classList.toggle("hidden", !match);
            });
        });
    })();
</script>
