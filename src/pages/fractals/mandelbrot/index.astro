<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Mandelbrot Viewer (Progressive, Static After Render)</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #eee;
                font-family:
                    system-ui,
                    -apple-system,
                    sans-serif;
                overflow: hidden;
            }

            #wrapper {
                position: fixed;
                inset: 0;
                overflow: hidden;
                background: #000;
            }

            canvas {
                display: block;
                width: 100%;
                height: 100%;
                touch-action: none;
                cursor: grab;
            }

            canvas:active {
                cursor: grabbing;
            }

            #controls {
                position: fixed;
                top: 10px;
                left: 10px;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.8);
                border-radius: 6px;
                font-size: 12px;
                line-height: 1.4;
                z-index: 10;
                user-select: none;
            }

            #controls label {
                display: flex;
                align-items: center;
                gap: 4px;
                margin-bottom: 4px;
            }

            #controls input[type="color"] {
                width: 20px;
                height: 20px;
                padding: 0;
                border: none;
                background: transparent;
            }

            #status {
                margin-top: 4px;
                opacity: 0.7;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco,
                    Consolas, "Liberation Mono", "Courier New", monospace;
            }
        </style>
    </head>
    <body>
        <div id="wrapper">
            <canvas id="view"></canvas>
        </div>

        <div id="controls">
            <div><strong>Palette</strong></div>
            <label>
                Inside
                <input type="color" id="insideColor" value="#000000" />
            </label>
            <label>
                Outside A
                <input type="color" id="outside1Color" value="#003366" />
            </label>
            <label>
                Outside B
                <input type="color" id="outside2Color" value="#ffaa33" />
            </label>
            <div id="status">Initializing…</div>
        </div>

        <script>
            (function () {
                const canvas = document.getElementById("view");
                const ctx = canvas.getContext("2d");
                const dpr = window.devicePixelRatio || 1;

                const insideInput = document.getElementById("insideColor");
                const outside1Input = document.getElementById("outside1Color");
                const outside2Input = document.getElementById("outside2Color");
                const statusEl = document.getElementById("status");

                // Base offscreen canvas where the fractal lives at screen resolution
                const dataCanvas = document.createElement("canvas");
                const dataCtx = dataCanvas.getContext("2d");

                // View transform (applied to main canvas when drawing dataCanvas)
                let viewScale = 1;
                let viewOffsetX = 0;
                let viewOffsetY = 0;

                // Rendering state
                let width = 0;
                let height = 0;
                let maxIter = 500;
                let rendering = false;
                let cancelRender = false;
                let finalIterations = null; // Float32Array of averaged escape values after supersampling
                let finalReady = false;

                // Pointer state for panning
                let isPanning = false;
                let panStartX = 0;
                let panStartY = 0;
                let panOrigOffsetX = 0;
                let panOrigOffsetY = 0;

                function resize() {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    width = Math.floor(w * dpr);
                    height = Math.floor(h * dpr);

                    canvas.width = width;
                    canvas.height = height;
                    canvas.style.width = w + "px";
                    canvas.style.height = h + "px";

                    dataCanvas.width = width;
                    dataCanvas.height = height;

                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;
                }

                function hexToRgb(hex) {
                    let h = hex.replace("#", "");
                    if (h.length === 3) {
                        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
                    }
                    const num = parseInt(h, 16);
                    return {
                        r: (num >> 16) & 255,
                        g: (num >> 8) & 255,
                        b: num & 255,
                    };
                }

                function lerp(a, b, t) {
                    return a + (b - a) * t;
                }

                function present() {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, width, height);
                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(dataCanvas, 0, 0);
                }

                function setStatus(text) {
                    statusEl.textContent = text;
                }

                // Compute smooth iteration count for a single complex point
                function mandelIterations(cx, cy, maxIterLocal) {
                    let x = 0;
                    let y = 0;
                    let xx = 0;
                    let yy = 0;
                    let iter = 0;
                    while (xx + yy <= 4 && iter < maxIterLocal) {
                        y = 2 * x * y + cy;
                        x = xx - yy + cx;
                        xx = x * x;
                        yy = y * y;
                        iter++;
                    }
                    if (iter >= maxIterLocal) {
                        return maxIterLocal;
                    }
                    // Smooth coloring
                    const mag = Math.sqrt(xx + yy);
                    const mu = iter + 1 - Math.log(Math.log(mag)) / Math.log(2);
                    return mu;
                }

                // Map pixel coordinates to Mandelbrot plane
                function pixelToComplex(px, py, w, h) {
                    // Classic view roughly centered at (-0.5, 0)
                    const aspect = w / h;
                    const scale = 3.0; // width in complex plane
                    const x0 = -0.5 - scale / 2;
                    const y0 = -scale / (2 * aspect);
                    const cx = x0 + (px / w) * scale;
                    const cy = y0 + ((py / h) * scale) / aspect;
                    return [cx, cy];
                }

                async function renderProgressive() {
                    rendering = true;
                    cancelRender = false;
                    finalReady = false;
                    finalIterations = null;

                    const passes = [
                        { step: 8, label: "Pass 1/4 (coarse)" },
                        { step: 4, label: "Pass 2/4 (medium)" },
                        { step: 1, label: "Pass 3/4 (full res)" },
                    ];

                    // Progressive passes on base resolution canvas
                    const baseImage = dataCtx.getImageData(0, 0, width, height);
                    const baseData = baseImage.data;

                    const inside = hexToRgb(insideInput.value);
                    const out1 = hexToRgb(outside1Input.value);
                    const out2 = hexToRgb(outside2Input.value);

                    for (let p = 0; p < passes.length; p++) {
                        const { step, label } = passes[p];
                        if (cancelRender) {
                            rendering = false;
                            setStatus("Render cancelled");
                            present();
                            return;
                        }
                        setStatus(label);

                        for (let py = 0; py < height; py += step) {
                            for (let px = 0; px < width; px += step) {
                                const [cx, cy] = pixelToComplex(
                                    px + step * 0.5,
                                    py + step * 0.5,
                                    width,
                                    height,
                                );
                                const t = mandelIterations(cx, cy, maxIter);
                                let r, g, b;

                                if (t >= maxIter) {
                                    r = inside.r;
                                    g = inside.g;
                                    b = inside.b;
                                } else {
                                    const norm = t / maxIter;
                                    const mix = norm;
                                    const r1 = lerp(out1.r, out2.r, mix);
                                    const g1 = lerp(out1.g, out2.g, mix);
                                    const b1 = lerp(out1.b, out2.b, mix);
                                    r = r1;
                                    g = g1;
                                    b = b1;
                                }

                                for (let sy = 0; sy < step; sy++) {
                                    const yy = py + sy;
                                    if (yy >= height) break;
                                    for (let sx = 0; sx < step; sx++) {
                                        const xx = px + sx;
                                        if (xx >= width) break;
                                        const idx = 4 * (yy * width + xx);
                                        baseData[idx] = r;
                                        baseData[idx + 1] = g;
                                        baseData[idx + 2] = b;
                                        baseData[idx + 3] = 255;
                                    }
                                }
                            }

                            if (cancelRender) break;
                            if ((py & 7) === 0) {
                                dataCtx.putImageData(baseImage, 0, 0);
                                present();
                                await new Promise(requestAnimationFrame);
                            }
                        }

                        if (cancelRender) {
                            rendering = false;
                            dataCtx.putImageData(baseImage, 0, 0);
                            present();
                            setStatus("Render cancelled");
                            return;
                        }
                    }

                    dataCtx.putImageData(baseImage, 0, 0);
                    present();

                    // Final supersampling pass: 2x width and 2x height (4x pixels)
                    await supersamplePass();
                }

                async function supersamplePass() {
                    if (cancelRender) {
                        rendering = false;
                        setStatus("Render cancelled");
                        present();
                        return;
                    }

                    setStatus("Pass 4/4 (supersampling)");

                    const hiW = width * 2;
                    const hiH = height * 2;

                    const hiIterations = new Float32Array(hiW * hiH);

                    // Compute hi-res iterations (no color yet)
                    for (let py = 0; py < hiH; py++) {
                        for (let px = 0; px < hiW; px++) {
                            const [cx, cy] = pixelToComplex(
                                px + 0.5,
                                py + 0.5,
                                hiW,
                                hiH,
                            );
                            const t = mandelIterations(cx, cy, maxIter);
                            hiIterations[py * hiW + px] = t;
                        }

                        if (cancelRender) {
                            rendering = false;
                            setStatus("Render cancelled");
                            present();
                            return;
                        }

                        if ((py & 15) === 0) {
                            await new Promise(requestAnimationFrame);
                        }
                    }

                    // Downsample: average 2×2 hi-res block into one screen pixel
                    finalIterations = new Float32Array(width * height);
                    const img = dataCtx.createImageData(width, height);
                    const data = img.data;

                    const inside = hexToRgb(insideInput.value);
                    const out1 = hexToRgb(outside1Input.value);
                    const out2 = hexToRgb(outside2Input.value);

                    for (let py = 0; py < height; py++) {
                        const hy0 = 2 * py;
                        const hy1 = hy0 + 1;
                        for (let px = 0; px < width; px++) {
                            const hx0 = 2 * px;
                            const hx1 = hx0 + 1;

                            const idx00 = hy0 * hiW + hx0;
                            const idx10 = hy0 * hiW + hx1;
                            const idx01 = hy1 * hiW + hx0;
                            const idx11 = hy1 * hiW + hx1;

                            const t00 = hiIterations[idx00];
                            const t10 = hiIterations[idx10];
                            const t01 = hiIterations[idx01];
                            const t11 = hiIterations[idx11];

                            const avgT = 0.25 * (t00 + t10 + t01 + t11);
                            finalIterations[py * width + px] = avgT;

                            let r, g, b;
                            if (avgT >= maxIter) {
                                r = inside.r;
                                g = inside.g;
                                b = inside.b;
                            } else {
                                const norm = avgT / maxIter;
                                const mix = norm;
                                const r1 = lerp(out1.r, out2.r, mix);
                                const g1 = lerp(out1.g, out2.g, mix);
                                const b1 = lerp(out1.b, out2.b, mix);
                                r = r1;
                                g = g1;
                                b = b1;
                            }

                            const idx = 4 * (py * width + px);
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                            data[idx + 3] = 255;
                        }

                        if ((py & 15) === 0) {
                            await new Promise(requestAnimationFrame);
                        }
                    }

                    dataCtx.putImageData(img, 0, 0);
                    present();

                    rendering = false;
                    finalReady = true;
                    setStatus("Done (static bitmap; pan/zoom is cheap)");
                }

                // Recolor final image without recomputing Mandelbrot (uses finalIterations)
                function recolorFinal() {
                    if (!finalReady || !finalIterations) return;

                    const img = dataCtx.createImageData(width, height);
                    const data = img.data;

                    const inside = hexToRgb(insideInput.value);
                    const out1 = hexToRgb(outside1Input.value);
                    const out2 = hexToRgb(outside2Input.value);

                    for (let py = 0; py < height; py++) {
                        for (let px = 0; px < width; px++) {
                            const t = finalIterations[py * width + px];
                            let r, g, b;

                            if (t >= maxIter) {
                                r = inside.r;
                                g = inside.g;
                                b = inside.b;
                            } else {
                                const norm = t / maxIter;
                                const mix = norm;
                                const r1 = lerp(out1.r, out2.r, mix);
                                const g1 = lerp(out1.g, out2.g, mix);
                                const b1 = lerp(out1.b, out2.b, mix);
                                r = r1;
                                g = g1;
                                b = b1;
                            }

                            const idx = 4 * (py * width + px);
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                            data[idx + 3] = 255;
                        }
                    }

                    dataCtx.putImageData(img, 0, 0);
                    present();
                }

                // Cancel any running render when user starts interacting
                function killRenderIfAny() {
                    if (rendering) {
                        cancelRender = true;
                    }
                }

                // Pan/zoom handlers
                canvas.addEventListener("pointerdown", (e) => {
                    killRenderIfAny();
                    isPanning = true;
                    canvas.setPointerCapture(e.pointerId);
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    panOrigOffsetX = viewOffsetX;
                    panOrigOffsetY = viewOffsetY;
                });

                canvas.addEventListener("pointermove", (e) => {
                    if (!isPanning) return;
                    const dx = (e.clientX - panStartX) * dpr;
                    const dy = (e.clientY - panStartY) * dpr;
                    viewOffsetX = panOrigOffsetX + dx;
                    viewOffsetY = panOrigOffsetY + dy;
                    present();
                });

                canvas.addEventListener("pointerup", (e) => {
                    if (!isPanning) return;
                    isPanning = false;
                    canvas.releasePointerCapture(e.pointerId);
                });

                canvas.addEventListener("pointercancel", (e) => {
                    if (!isPanning) return;
                    isPanning = false;
                    canvas.releasePointerCapture(e.pointerId);
                });

                canvas.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();
                        killRenderIfAny();

                        const rect = canvas.getBoundingClientRect();
                        const cx = (e.clientX - rect.left) * dpr;
                        const cy = (e.clientY - rect.top) * dpr;

                        const delta = -e.deltaY;
                        const zoomFactor = Math.exp(delta * 0.001); // smooth-ish

                        const newScale = viewScale * zoomFactor;

                        // Zoom around cursor
                        viewOffsetX = cx - zoomFactor * (cx - viewOffsetX);
                        viewOffsetY = cy - zoomFactor * (cy - viewOffsetY);
                        viewScale = newScale;

                        present();
                    },
                    { passive: false },
                );

                insideInput.addEventListener("input", () => {
                    if (finalReady) recolorFinal();
                });
                outside1Input.addEventListener("input", () => {
                    if (finalReady) recolorFinal();
                });
                outside2Input.addEventListener("input", () => {
                    if (finalReady) recolorFinal();
                });

                // Init
                resize();
                present();
                setStatus("Rendering…");
                renderProgressive();

                // Optional: if you want, you could re-render on window resize.
                // That is *not* required for your description, so omitted.
            })();
        </script>
    </body>
</html>
