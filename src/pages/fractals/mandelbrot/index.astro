<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>
            Mandelbrot WASM (JS pan/zoom, pixel-size stages, JS palette)
        </title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #eee;
                font-family: system-ui, sans-serif;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
                display: block;
                touch-action: none;
                cursor: grab;
            }
            canvas:active {
                cursor: grabbing;
            }
            #controls {
                position: fixed;
                top: 10px;
                left: 10px;
                padding: 6px 8px;
                background: rgba(0, 0, 0, 0.75);
                border-radius: 6px;
                font-size: 12px;
                z-index: 10;
                user-select: none;
            }
            #controls label {
                display: flex;
                align-items: center;
                gap: 4px;
                margin-bottom: 4px;
            }
            #controls input[type="color"] {
                width: 20px;
                height: 20px;
                padding: 0;
                border: none;
                background: transparent;
            }
            #controls input[type="range"] {
                width: 140px;
            }
            #status {
                margin-top: 4px;
                opacity: 0.7;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco,
                    Consolas, "Liberation Mono", "Courier New", monospace;
            }
        </style>
    </head>
    <body>
        <canvas id="view"></canvas>

        <div id="controls">
            <div><strong>Palette</strong></div>
            <label>
                Color
                <input type="color" id="fc" />
            </label>
            <label>
                Glow
                <input type="range" id="bw" min="0" max="100" value="80" />
            </label>
            <div id="status">WASM loading…</div>
        </div>

        <!-- Astro-friendly: wasm JS loader is marked inline -->
        <script is:inline src="/mandel.js"></script>

        <script>
            (function () {
                const canvas = document.getElementById("view");
                const ctx = canvas.getContext("2d");

                const fc = document.getElementById("fc");
                const bw = document.getElementById("bw");
                const status = document.getElementById("status");

                fc.value = "#00ffff";

                // World view in complex plane
                let worldCenterX = -0.75;
                let worldCenterY = 0.0;
                let worldScale = 1.5;

                // Circle cutoff in world coords
                const CIRC_X = -0.75;
                const CIRC_Y = 0.0;
                const CIRC_R = 1.5;

                let fullW = 0;
                let fullH = 0;

                // Last rendered colored frame, used for JS pan/zoom
                const baseCanvas = document.createElement("canvas");
                const baseCtx = baseCanvas.getContext("2d");
                let baseValid = false;

                // Offscreen buffer for each WASM stage
                const bufCanvas = document.createElement("canvas");
                const bufCtx = bufCanvas.getContext("2d");

                // Interactive transform applied to baseCanvas
                let viewScale = 1;
                let viewOffsetX = 0;
                let viewOffsetY = 0;

                // WASM
                let wasmReady = false;
                let initFB = null;
                let getPtr = null;
                let renderFrame = null;

                let fbW = 0;
                let fbH = 0;
                let fbPtr = 0;
                let fbView = null;

                // All stages use same maxIter; stages differ only in pixel size.
                const MAX_ITER = 500;

                // Progressive pixel sizes:
                // 64, 32, 16, 8, 4, 2, 1, 0.5 (last one is 2x resolution downscaled)
                const STAGES = [
                    { pixelSize: 64, samplesDim: 1 },
                    { pixelSize: 32, samplesDim: 1 },
                    { pixelSize: 16, samplesDim: 1 },
                    { pixelSize: 8, samplesDim: 1 },
                    { pixelSize: 4, samplesDim: 1 },
                    { pixelSize: 2, samplesDim: 1 },
                    { pixelSize: 1, samplesDim: 1 },
                    { pixelSize: 1, samplesDim: 4 },
                ];

                // Hard pixel cap to avoid OOM
                const MAX_PIXELS = 1_000_000; // ~4 MB framebuffer

                let currentStage = -1;
                let stagePending = false;

                // Interaction timing
                let interactionActive = false;
                let lastInteractionTime = 0;
                const INTERACTION_SETTLE_MS = 250;

                // Panning state
                let isPanning = false;
                let panStartX = 0;
                let panStartY = 0;
                let panStartCenterX = 0;
                let panStartCenterY = 0;

                function setStatus(msg) {
                    const mode =
                        currentStage >= 0
                            ? `render-stage=${currentStage}`
                            : interactionActive
                              ? "interactive"
                              : "idle";
                    status.textContent = `${msg} | mode=${mode} | WASM=${
                        wasmReady ? "on" : "off"
                    }`;
                }

                function hexToRgb(hex) {
                    let h = hex.replace("#", "");
                    if (h.length === 3) {
                        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
                    }
                    const num = parseInt(h, 16);
                    return {
                        r: (num >> 16) & 255,
                        g: (num >> 8) & 255,
                        b: num & 255,
                    };
                }

                // Glow slider: 0 = wide/soft, 100 = thin/bright
                function getBandWidth() {
                    const raw = parseInt(bw.value, 10) || 0;
                    const sNorm = Math.min(1, Math.max(0, raw / 100));
                    const sInv = 1 - sNorm;
                    const minW = 0.1;
                    const maxW = 0.95;
                    return minW + sInv * (maxW - minW);
                }

                function currentWorldParams() {
                    const aspect = fullW / fullH;
                    const worldWidth = worldScale * 2;
                    const worldHeight = worldWidth / aspect;
                    const worldX0 = worldCenterX - worldWidth / 2;
                    const worldY0 = worldCenterY - worldHeight / 2;
                    return { worldWidth, worldHeight, worldX0, worldY0 };
                }

                function screenToWorld(sx, sy) {
                    const { worldWidth, worldHeight, worldX0, worldY0 } =
                        currentWorldParams();
                    const u = sx / fullW;
                    const v = sy / fullH;
                    const cx = worldX0 + u * worldWidth;
                    const cy = worldY0 + v * worldHeight;
                    return { cx, cy };
                }

                function resize() {
                    const cssW = window.innerWidth;
                    const cssH = window.innerHeight;

                    // 1:1 mapping between CSS pixels and canvas pixels
                    canvas.style.width = cssW + "px";
                    canvas.style.height = cssH + "px";

                    canvas.width = cssW;
                    canvas.height = cssH;

                    fullW = canvas.width;
                    fullH = canvas.height;

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;

                    baseValid = false;
                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    if (wasmReady) {
                        fbView = null;
                        requestFullRender();
                    }
                }

                window.addEventListener("resize", () => {
                    resize();
                    markInteraction();
                });

                function markInteraction() {
                    interactionActive = true;
                    lastInteractionTime = performance.now();
                }

                function requestFullRender() {
                    if (!wasmReady) return;
                    currentStage = 0;
                    stagePending = true;
                }

                // JS colorization: grayscale (0..255) → RGBA
                function colorizeGray(gray, w, h) {
                    const N = gray.length;
                    const out = new Uint8ClampedArray(N * 4);

                    const color = hexToRgb(fc.value);
                    const bandWidth = getBandWidth();

                    let o = 0;
                    for (let i = 0; i < N; i++) {
                        const gNorm = gray[i] / 255;
                        let r, g, b;

                        if (gNorm <= 0) {
                            r = g = b = 0;
                        } else {
                            let wVal;
                            if (gNorm >= bandWidth) wVal = 1;
                            else wVal = gNorm / bandWidth;

                            r = color.r * wVal;
                            g = color.g * wVal;
                            b = color.b * wVal;
                        }

                        out[o++] = r;
                        out[o++] = g;
                        out[o++] = b;
                        out[o++] = 255;
                    }
                    return out;
                }

                // JS-only pan
                canvas.addEventListener("pointerdown", (e) => {
                    isPanning = true;
                    canvas.setPointerCapture(e.pointerId);
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    panStartCenterX = worldCenterX;
                    panStartCenterY = worldCenterY;
                    markInteraction();
                });

                canvas.addEventListener("pointermove", (e) => {
                    if (!isPanning) return;
                    const dx = e.clientX - panStartX;
                    const dy = e.clientY - panStartY;

                    const { worldWidth, worldHeight } = currentWorldParams();

                    worldCenterX =
                        panStartCenterX -
                        (dx / (window.innerWidth || 1)) * worldWidth;
                    worldCenterY =
                        panStartCenterY -
                        (dy / (window.innerHeight || 1)) * worldHeight;

                    viewOffsetX = dx;
                    viewOffsetY = dy;

                    markInteraction();
                });

                function endPan(e) {
                    if (!isPanning) return;
                    isPanning = false;
                    try {
                        canvas.releasePointerCapture(e.pointerId);
                    } catch (_) {}
                    markInteraction();
                }

                canvas.addEventListener("pointerup", endPan);
                canvas.addEventListener("pointercancel", endPan);

                // JS-only zoom
                canvas.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();

                        const rect = canvas.getBoundingClientRect();
                        const sx = e.clientX - rect.left;
                        const sy = e.clientY - rect.top;

                        const before = screenToWorld(sx, sy);

                        const delta = -e.deltaY;
                        const zoomFactor = Math.exp(delta * 0.001);
                        worldScale /= zoomFactor;

                        const after = screenToWorld(sx, sy);
                        worldCenterX += before.cx - after.cx;
                        worldCenterY += before.cy - after.cy;

                        const oldScale = viewScale;
                        const newScale = viewScale * zoomFactor;

                        viewOffsetX =
                            sx - (sx - viewOffsetX) * (newScale / oldScale);
                        viewOffsetY =
                            sy - (sy - viewOffsetY) * (newScale / oldScale);
                        viewScale = newScale;

                        markInteraction();
                    },
                    { passive: false },
                );

                // ---------- FIXED PALETTE HANDLING ----------
                function handlePaletteChange() {
                    // Throw away current base image
                    baseValid = false;
                    // Cancel any in-progress stage
                    stagePending = false;
                    currentStage = -1;

                    // This is not an "interaction" in the pan/zoom sense;
                    // go straight into a fresh staged render.
                    interactionActive = false;
                    isPanning = false;
                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    requestFullRender();
                }

                fc.addEventListener("input", handlePaletteChange);
                bw.addEventListener("input", handlePaletteChange);
                // ---------- END FIX ----------

                function drawInteractiveFrame() {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);

                    if (!baseValid) return;

                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(baseCanvas, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                function drawStableBase() {
                    if (!baseValid) return;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(baseCanvas, 0, 0);
                }

                function runStage(stageIndex) {
                    if (
                        !wasmReady ||
                        stageIndex < 0 ||
                        stageIndex >= STAGES.length
                    ) {
                        currentStage = -1;
                        stagePending = false;
                        return;
                    }

                    const stage = STAGES[stageIndex];
                    const pixelSize = stage.pixelSize; // 64, 32, ..., 1, 0.5
                    const samplesDim = stage.samplesDim;

                    // pixelSize = how many screen pixels one computed pixel covers.
                    // So framebuffer resolution is fullW/pixelSize × fullH/pixelSize.
                    const baseFactor = 1 / pixelSize;
                    let targetW = Math.max(1, Math.floor(fullW * baseFactor));
                    let targetH = Math.max(1, Math.floor(fullH * baseFactor));

                    fbW = targetW;
                    fbH = targetH;

                    // Alloc framebuffer in WASM
                    initFB(fbW, fbH);
                    fbPtr = getPtr();

                    if (!Module.HEAPU8 || !Module.HEAPU8.buffer) {
                        setStatus("WASM: no HEAPU8");
                        fbView = null;
                        currentStage = -1;
                        stagePending = false;
                        return;
                    }

                    fbView = new Uint8ClampedArray(
                        Module.HEAPU8.buffer,
                        fbPtr,
                        fbW * fbH * 4,
                    );

                    // All stages use same iteration count
                    renderFrame(
                        worldCenterX,
                        worldCenterY,
                        worldScale,
                        MAX_ITER,
                        samplesDim,
                        CIRC_X,
                        CIRC_Y,
                        CIRC_R,
                    );

                    // Extract grayscale
                    const gray = new Uint8Array(fbW * fbH);
                    for (let i = 0, j = 0; i < gray.length; i++, j += 4) {
                        gray[i] = fbView[j];
                    }

                    // Colorize
                    const colored = colorizeGray(gray, fbW, fbH);

                    // Put into temporary canvas
                    bufCanvas.width = fbW;
                    bufCanvas.height = fbH;

                    const img = new ImageData(colored, fbW, fbH);
                    bufCtx.putImageData(img, 0, 0);

                    // Scale to screen
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        fbW,
                        fbH,
                        0,
                        0,
                        fullW,
                        fullH,
                    );

                    // Update baseCanvas for panning/zooming
                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;
                    baseCtx.clearRect(0, 0, fullW, fullH);
                    baseCtx.drawImage(canvas, 0, 0);
                    baseValid = true;

                    setStatus(
                        `stage=${stageIndex} pixelSize=${pixelSize} fb=${fbW}x${fbH}`,
                    );

                    currentStage++;
                    stagePending = currentStage < STAGES.length;
                    if (!stagePending) currentStage = -1;
                }

                function loop() {
                    const now = performance.now();

                    // When user stops interacting, schedule new staged render
                    if (
                        interactionActive &&
                        now - lastInteractionTime > INTERACTION_SETTLE_MS &&
                        currentStage === -1
                    ) {
                        interactionActive = false;
                        viewScale = 1;
                        viewOffsetX = 0;
                        viewOffsetY = 0;
                        requestFullRender();
                    }

                    if (interactionActive) {
                        drawInteractiveFrame();
                    } else if (stagePending) {
                        runStage(currentStage);
                    } else {
                        drawStableBase();
                    }

                    requestAnimationFrame(loop);
                }

                function initAfterWasm() {
                    initFB = Module.cwrap("init_framebuffer", null, [
                        "number",
                        "number",
                    ]);
                    getPtr = Module.cwrap("get_framebuffer_ptr", "number", []);
                    renderFrame = Module.cwrap("render_frame", null, [
                        "number",
                        "number",
                        "number", // cx, cy, scale
                        "number", // maxIter
                        "number", // samplesPerDim
                        "number",
                        "number",
                        "number", // circx, circy, circr
                    ]);

                    wasmReady = true;
                    setStatus("WASM ready");

                    resize();
                    requestFullRender();
                    loop();
                }

                if (typeof Module === "undefined") {
                    window.Module = {};
                }
                Module = Module || {};
                Module.onRuntimeInitialized = initAfterWasm;

                if (Module.calledRun) {
                    initAfterWasm();
                }
            })();
        </script>
    </body>
</html>
