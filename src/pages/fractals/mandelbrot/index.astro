<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Mandelbrot Viewer (CPU, Progressive, Supersampled Glow)</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #eee;
                font-family:
                    system-ui,
                    -apple-system,
                    sans-serif;
                overflow: hidden;
            }

            #wrapper {
                position: fixed;
                inset: 0;
                overflow: hidden;
                background: #000;
            }

            canvas {
                display: block;
                width: 100%;
                height: 100%;
                touch-action: none;
                cursor: grab;
            }

            canvas:active {
                cursor: grabbing;
            }

            #controls {
                position: fixed;
                top: 10px;
                left: 10px;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.8);
                border-radius: 6px;
                font-size: 12px;
                line-height: 1.4;
                z-index: 10;
                user-select: none;
            }

            #controls label {
                display: flex;
                align-items: center;
                gap: 4px;
                margin-bottom: 4px;
            }

            #controls input[type="color"] {
                width: 20px;
                height: 20px;
                padding: 0;
                border: none;
                background: transparent;
            }

            #controls input[type="range"] {
                width: 140px;
            }

            #status {
                margin-top: 4px;
                opacity: 0.7;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco,
                    Consolas, "Liberation Mono", "Courier New", monospace;
            }
        </style>
    </head>
    <body>
        <div id="wrapper">
            <canvas id="view"></canvas>
        </div>

        <div id="controls">
            <div><strong>Palette</strong></div>
            <label>
                Fractal color
                <input type="color" id="fractalColor" />
            </label>
            <label>
                Glow width
                <input type="range" id="fractalStrength" />
            </label>
            <div id="status">Initializing…</div>
        </div>

        <script>
            (function () {
                const CONFIG = {
                    MAX_ITER: 500,
                    FRACTAL_COLOR_START: "#00ffff",
                    STRENGTH_MIN: 0,
                    STRENGTH_MAX: 100,
                    STRENGTH_START: 80,
                };

                // Radial geometry in the complex plane
                const R_SET = 2.0; // Mandelbrot "cut" radius
                const R_MARGIN = 0.25; // extra margin beyond r=2
                const R_WORLD = R_SET + R_MARGIN; // world extends to ±R_WORLD
                const R_CLIP = R_SET; // hard cut to black beyond this
                const R_FADE = 1.8; // start fading here toward R_CLIP

                function radialWeight(r) {
                    if (r >= R_CLIP) return 0;
                    if (r <= R_FADE) return 1;
                    const t = (R_CLIP - r) / (R_CLIP - R_FADE); // 0..1
                    return t < 0 ? 0 : t > 1 ? 1 : t;
                }

                const canvas = document.getElementById("view");
                const ctx = canvas.getContext("2d");
                const deviceDpr = window.devicePixelRatio || 1;

                const fractalInput = document.getElementById("fractalColor");
                const fractalStrengthInput =
                    document.getElementById("fractalStrength");
                const statusEl = document.getElementById("status");

                fractalInput.value = CONFIG.FRACTAL_COLOR_START;
                fractalStrengthInput.min = String(CONFIG.STRENGTH_MIN);
                fractalStrengthInput.max = String(CONFIG.STRENGTH_MAX);
                fractalStrengthInput.value = String(CONFIG.STRENGTH_START);

                // Offscreen canvas at screen resolution
                const dataCanvas = document.createElement("canvas");
                const dataCtx = dataCanvas.getContext("2d");

                let width = 0;
                let height = 0;
                let internalW = 0;
                let internalH = 0;

                let viewScale = 1;
                let viewOffsetX = 0;
                let viewOffsetY = 0;

                const maxIter = CONFIG.MAX_ITER;
                let rendering = false;
                let cancelRender = false;
                let finalReady = false;

                let iterations = null; // Float32Array(internalW * internalH)
                let radialMask = null; // Float32Array(internalW * internalH), 0..1
                let img = null; // ImageData
                let imgData = null; // Uint8ClampedArray

                // Panning
                let isPanning = false;
                let panStartX = 0;
                let panStartY = 0;
                let panOrigOffsetX = 0;
                let panOrigOffsetY = 0;

                // Palette scheduling
                let paletteDirty = false;
                let paletteRecolorInProgress = false;

                function resize() {
                    const cssW = window.innerWidth;
                    const cssH = window.innerHeight;

                    width = Math.floor(cssW * deviceDpr);
                    height = Math.floor(cssH * deviceDpr);
                    canvas.width = width;
                    canvas.height = height;
                    canvas.style.width = cssW + "px";
                    canvas.style.height = cssH + "px";

                    internalW = width;
                    internalH = height;
                    dataCanvas.width = internalW;
                    dataCanvas.height = internalH;

                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    iterations = new Float32Array(internalW * internalH);
                    radialMask = new Float32Array(internalW * internalH);
                    for (let i = 0; i < iterations.length; i++) {
                        iterations[i] = -1;
                        radialMask[i] = 1;
                    }

                    img = dataCtx.createImageData(internalW, internalH);
                    imgData = img.data;
                }

                function hexToRgb(hex) {
                    let h = hex.replace("#", "");
                    if (h.length === 3) {
                        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
                    }
                    const num = parseInt(h, 16);
                    return {
                        r: (num >> 16) & 255,
                        g: (num >> 8) & 255,
                        b: num & 255,
                    };
                }

                function setStatus(text) {
                    statusEl.textContent = text;
                }

                function present() {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, width, height);

                    const destW = width * viewScale;
                    const destH = height * viewScale;
                    const destX = viewOffsetX;
                    const destY = viewOffsetY;

                    dataCtx.putImageData(img, 0, 0);
                    ctx.drawImage(
                        dataCanvas,
                        0,
                        0,
                        internalW,
                        internalH,
                        destX,
                        destY,
                        destW,
                        destH,
                    );
                }

                function mandelIterations(cx, cy, maxIterLocal) {
                    let x = 0;
                    let y = 0;
                    let xx = 0;
                    let yy = 0;
                    let iter = 0;
                    while (xx + yy <= 4 && iter < maxIterLocal) {
                        y = 2 * x * y + cy;
                        x = xx - yy + cx;
                        xx = x * x;
                        yy = y * y;
                        iter++;
                    }
                    if (iter >= maxIterLocal) return maxIterLocal;
                    const mag = Math.sqrt(xx + yy);
                    const mu = iter + 1 - Math.log(Math.log(mag)) / Math.log(2);
                    return mu;
                }

                // Map pixel to complex plane, centered at origin,
                // world extends to ±R_WORLD in both axes (with aspect-aware scaling).
                function pixelToComplex(px, py, W, H) {
                    const aspect = W / H;
                    const worldH = 2 * R_WORLD; // -R_WORLD .. +R_WORLD
                    const worldW = worldH * aspect;
                    const x0 = -worldW / 2;
                    const y0 = -R_WORLD;

                    const cx = x0 + (px / W) * worldW;
                    const cy = y0 + (py / H) * worldH;
                    return [cx, cy];
                }

                // Slider -> band width (how much of norm space is used for glow)
                // Inverted so "max glow" is at the right end of the slider.
                function getBandWidth() {
                    const raw = parseInt(fractalStrengthInput.value, 10) || 0;
                    const sNorm = Math.min(
                        1,
                        Math.max(
                            0,
                            (raw - CONFIG.STRENGTH_MIN) /
                                (CONFIG.STRENGTH_MAX - CONFIG.STRENGTH_MIN ||
                                    1),
                        ),
                    );
                    const sInv = 1 - sNorm; // invert slider response
                    const minW = 0.1;
                    const maxW = 0.95;
                    return minW + sInv * (maxW - minW);
                }

                function getPaletteParams() {
                    return {
                        frac: hexToRgb(fractalInput.value),
                        bandWidth: getBandWidth(),
                    };
                }

                // Monotone ramp:
                // - t >= maxIter (inside or "clipped") -> black
                // - norm in (0..bandWidth) ramps 0..1
                // - norm >= bandWidth -> full color
                function colorForT(t, params) {
                    if (t <= 0 || t >= maxIter) {
                        return { r: 0, g: 0, b: 0 };
                    }
                    const { frac, bandWidth } = params;
                    const norm = t / maxIter; // 0..1

                    let w;
                    if (norm <= 0) {
                        w = 0;
                    } else if (norm >= bandWidth) {
                        w = 1;
                    } else {
                        w = norm / bandWidth;
                    }

                    return {
                        r: frac.r * w,
                        g: frac.g * w,
                        b: frac.b * w,
                    };
                }

                // Full recolor with current palette; used for palette changes
                function recolorFromIterations() {
                    if (!iterations || !imgData) return;
                    const params = getPaletteParams();

                    for (let idxPix = 0; idxPix < iterations.length; idxPix++) {
                        const t = iterations[idxPix];
                        const mask =
                            radialMask &&
                            radialMask.length === iterations.length
                                ? radialMask[idxPix]
                                : 1;
                        const { r, g, b } = colorForT(t, params);
                        const idx4 = idxPix * 4;
                        imgData[idx4] = r * mask;
                        imgData[idx4 + 1] = g * mask;
                        imgData[idx4 + 2] = b * mask;
                        imgData[idx4 + 3] = 255;
                    }
                    present();
                }

                function requestPaletteRecolor() {
                    paletteDirty = true;
                }

                // Coalesce palette changes to once per animation frame
                function paletteLoop() {
                    if (paletteDirty && !paletteRecolorInProgress) {
                        paletteDirty = false;
                        paletteRecolorInProgress = true;
                        recolorFromIterations();
                        paletteRecolorInProgress = false;
                    }
                    requestAnimationFrame(paletteLoop);
                }

                // Final supersample pass:
                // compute at 2× resolution, but downsample and paint each
                // destination row as soon as both source rows are available,
                // so you see the supersampled image creep in gradually.
                async function supersamplePass() {
                    const upscale = 2;
                    const hiW = internalW * upscale;
                    const hiH = internalH * upscale;
                    setStatus(`Pass 7/7 (supersample ${hiW}×${hiH})`);

                    const hiIter = new Float32Array(hiW * hiH);

                    // World mapping for hi-res, same origin-centered disc + margin.
                    const aspect = hiW / hiH;
                    const worldH = 2 * R_WORLD;
                    const worldW = worldH * aspect;
                    const x0 = -worldW / 2;
                    const y0 = -R_WORLD;

                    const params = getPaletteParams();
                    let lastYield = performance.now();

                    // High-res iteration
                    for (let py = 0; py < hiH; py++) {
                        const v = py / hiH;
                        const cy = y0 + v * worldH;

                        for (let px = 0; px < hiW; px++) {
                            const u = px / hiW;
                            const cx = x0 + u * worldW;
                            const r2 = cx * cx + cy * cy;
                            const t =
                                r2 > R_CLIP * R_CLIP
                                    ? maxIter // outside r=2 -> force black
                                    : mandelIterations(cx, cy, maxIter);
                            hiIter[py * hiW + px] = t;
                        }

                        if (cancelRender) return;

                        // Every pair of hi-res rows gives us one dest row.
                        if (py % upscale === upscale - 1) {
                            const y = (py - (upscale - 1)) / upscale;
                            if (y < internalH) {
                                const yy0 = y * upscale;
                                const yy1 = Math.min(yy0 + 1, hiH - 1);

                                for (let x = 0; x < internalW; x++) {
                                    const xx0 = x * upscale;
                                    const xx1 = Math.min(xx0 + 1, hiW - 1);

                                    // Compute complex coordinate at dest pixel center
                                    const [cx0, cy0] = pixelToComplex(
                                        x + 0.5,
                                        y + 0.5,
                                        internalW,
                                        internalH,
                                    );
                                    const r = Math.sqrt(cx0 * cx0 + cy0 * cy0);
                                    const mask = radialWeight(r);

                                    let tAvg;
                                    if (mask === 0) {
                                        tAvg = maxIter;
                                    } else {
                                        let sum = 0;
                                        let count = 0;
                                        let allInside = true;

                                        const idxs = [
                                            yy0 * hiW + xx0,
                                            yy0 * hiW + xx1,
                                            yy1 * hiW + xx0,
                                            yy1 * hiW + xx1,
                                        ];

                                        for (let k = 0; k < 4; k++) {
                                            const t = hiIter[idxs[k]];
                                            if (t >= maxIter) continue;
                                            allInside = false;
                                            sum += t;
                                            count++;
                                        }

                                        if (allInside || count === 0) {
                                            tAvg = maxIter;
                                        } else {
                                            tAvg = sum / count;
                                        }
                                    }

                                    const idxPix = y * internalW + x;
                                    iterations[idxPix] = tAvg;
                                    radialMask[idxPix] = mask;

                                    const {
                                        r: cr,
                                        g: cg,
                                        b: cb,
                                    } = colorForT(tAvg, params);
                                    const idx4 = idxPix * 4;
                                    imgData[idx4] = cr * mask;
                                    imgData[idx4 + 1] = cg * mask;
                                    imgData[idx4 + 2] = cb * mask;
                                    imgData[idx4 + 3] = 255;
                                }
                            }
                        }

                        const now = performance.now();
                        if (now - lastYield > 12) {
                            present();
                            await new Promise(requestAnimationFrame);
                            lastYield = performance.now();
                        }
                    }

                    present();
                }

                async function renderProgressive() {
                    rendering = true;
                    cancelRender = false;
                    finalReady = false;

                    for (let i = 0; i < iterations.length; i++) {
                        iterations[i] = -1;
                        radialMask[i] = 1;
                    }

                    const passes = [
                        { step: 64, label: "Pass 1/6 (step=64)" },
                        { step: 32, label: "Pass 2/6 (step=32)" },
                        { step: 16, label: "Pass 3/6 (step=16)" },
                        { step: 8, label: "Pass 4/6 (step=8)" },
                        { step: 4, label: "Pass 5/6 (step=4)" },
                        { step: 1, label: "Pass 6/6 (step=1)" },
                    ];

                    let lastYield = performance.now();

                    for (let p = 0; p < passes.length; p++) {
                        const { step, label } = passes[p];
                        if (cancelRender) {
                            rendering = false;
                            setStatus("Render cancelled");
                            present();
                            return;
                        }
                        setStatus(`${label}  [${internalW}×${internalH}]`);

                        for (let py = 0; py < internalH; py += step) {
                            const params = getPaletteParams();

                            for (let px = 0; px < internalW; px += step) {
                                const [cx, cy] = pixelToComplex(
                                    px + step * 0.5,
                                    py + step * 0.5,
                                    internalW,
                                    internalH,
                                );
                                const r = Math.sqrt(cx * cx + cy * cy);
                                const maskBlock = radialWeight(r);

                                let tBlock;
                                if (maskBlock === 0) {
                                    tBlock = maxIter;
                                } else {
                                    tBlock = mandelIterations(cx, cy, maxIter);
                                }

                                for (let sy = 0; sy < step; sy++) {
                                    const yy = py + sy;
                                    if (yy >= internalH) break;
                                    for (let sx = 0; sx < step; sx++) {
                                        const xx = px + sx;
                                        if (xx >= internalW) break;

                                        const idxPix = yy * internalW + xx;
                                        iterations[idxPix] = tBlock;
                                        radialMask[idxPix] = maskBlock;

                                        const {
                                            r: cr,
                                            g: cg,
                                            b: cb,
                                        } = colorForT(tBlock, params);
                                        const idx4 = idxPix * 4;
                                        imgData[idx4] = cr * maskBlock;
                                        imgData[idx4 + 1] = cg * maskBlock;
                                        imgData[idx4 + 2] = cb * maskBlock;
                                        imgData[idx4 + 3] = 255;
                                    }
                                }
                            }

                            if (cancelRender) break;

                            const now = performance.now();
                            if (now - lastYield > 12) {
                                present();
                                await new Promise(requestAnimationFrame);
                                lastYield = performance.now();
                            }
                        }

                        if (cancelRender) {
                            rendering = false;
                            setStatus("Render cancelled");
                            present();
                            return;
                        }
                    }

                    if (!cancelRender) {
                        await supersamplePass();
                    }

                    rendering = false;
                    finalReady = true;
                    setStatus(`Done [${internalW}×${internalH}, supersampled]`);
                    present();
                }

                function killRenderIfAny() {
                    if (rendering) cancelRender = true;
                }

                // Panning
                canvas.addEventListener("pointerdown", (e) => {
                    killRenderIfAny();
                    isPanning = true;
                    canvas.setPointerCapture(e.pointerId);
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    panOrigOffsetX = viewOffsetX;
                    panOrigOffsetY = viewOffsetY;
                });

                canvas.addEventListener("pointermove", (e) => {
                    if (!isPanning) return;
                    const dx = (e.clientX - panStartX) * deviceDpr;
                    const dy = (e.clientY - panStartY) * deviceDpr;
                    viewOffsetX = panOrigOffsetX + dx;
                    viewOffsetY = panOrigOffsetY + dy;
                    present();
                });

                canvas.addEventListener("pointerup", (e) => {
                    if (!isPanning) return;
                    isPanning = false;
                    canvas.releasePointerCapture(e.pointerId);
                });

                canvas.addEventListener("pointercancel", (e) => {
                    if (!isPanning) return;
                    isPanning = false;
                    canvas.releasePointerCapture(e.pointerId);
                });

                // Zoom
                canvas.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();
                        killRenderIfAny();

                        const rect = canvas.getBoundingClientRect();
                        const cx = (e.clientX - rect.left) * deviceDpr;
                        const cy = (e.clientY - rect.top) * deviceDpr;

                        const delta = -e.deltaY;
                        const zoomFactor = Math.exp(delta * 0.001);

                        viewOffsetX = cx - zoomFactor * (cx - viewOffsetX);
                        viewOffsetY = cy - zoomFactor * (cy - viewOffsetY);
                        viewScale *= zoomFactor;

                        present();
                    },
                    { passive: false },
                );

                // Palette changes: mark dirty, recolor scheduled in paletteLoop
                fractalInput.addEventListener("input", requestPaletteRecolor);
                fractalStrengthInput.addEventListener(
                    "input",
                    requestPaletteRecolor,
                );

                resize();
                present();
                setStatus("Rendering…");
                paletteLoop();
                renderProgressive();
            })();
        </script>
    </body>
</html>
