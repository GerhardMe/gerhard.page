---
const title = "Mandelbrot Explorer";
---

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>{title}</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                height: 100%;
                width: 100%;
                background: #000;
                color: #fff;
                font-family: system-ui, sans-serif;
            }
            body {
                margin: 0;
                padding: 0;
            }
            #wrapper {
                position: fixed;
                inset: 0;
                overflow: hidden;
            }
            #mandel {
                width: 100%;
                height: 100%;
                display: block;
                touch-action: none;
                cursor: grab;
            }
            #mandel.dragging {
                cursor: grabbing;
            }
            #info {
                position: absolute;
                left: 0.5rem;
                bottom: 0.5rem;
                padding: 0.25rem 0.5rem;
                font-size: 0.7rem;
                background: rgba(0, 0, 0, 0.5);
                border-radius: 4px;
                pointer-events: none;
                opacity: 0.7;
            }
        </style>
    </head>
    <body>
        <div id="wrapper">
            <canvas id="mandel"></canvas>
            <div id="info"></div>
        </div>

        <script>
            window.addEventListener("load", () => {
                const canvas = document.getElementById("mandel");
                const infoEl = document.getElementById("info");
                const ctx = canvas.getContext("2d");

                if (!ctx) {
                    if (infoEl) infoEl.textContent = "2D canvas not supported";
                    return;
                }

                // --------- view state ---------
                let centerX = -0.5;
                let centerY = 0.0;
                let scale = 1.5; // half-height in complex plane

                const BASE_MAX_ITER = 250;

                // rendering state
                const START_STEP = 32; // block size in pixels (start coarse)
                let currentStep = START_STEP;
                let tileX = 0;
                let tileY = 0;
                let renderId = 0; // used to cancel outdated renders

                // interaction state
                let isDragging = false;
                let lastX = 0;
                let lastY = 0;

                // last finished image (for preview warping)
                let lastImage = null;
                let lastView = {
                    centerX: centerX,
                    centerY: centerY,
                    scale: scale,
                };

                // --------- helpers ---------
                function resizeCanvas() {
                    const rect = canvas.getBoundingClientRect();
                    const width = Math.max(1, Math.floor(rect.width));
                    const height = Math.max(1, Math.floor(rect.height));
                    if (canvas.width !== width || canvas.height !== height) {
                        canvas.width = width;
                        canvas.height = height;
                        // stretch old image as best-effort preview
                        drawPreviewFromLastImage();
                        resetRender({ clear: true });
                    }
                }

                function maxIterForScale() {
                    const s = scale;
                    const base = BASE_MAX_ITER;
                    const factor = 1 + Math.log10(1 / s + 1);
                    return Math.floor(base * factor);
                }

                function updateInfo(textExtra = "") {
                    if (!infoEl) return;
                    const txt =
                        `center=(${centerX.toFixed(6)}, ${centerY.toFixed(6)}) ` +
                        `scale=${scale.toExponential(3)} ` +
                        `maxIter=${maxIterForScale()}` +
                        (textExtra ? " — " + textExtra : "");
                    infoEl.textContent = txt;
                }

                function pixelToComplex(px, py) {
                    const w = canvas.width;
                    const h = canvas.height;
                    const aspect = w / h;

                    const nx = (px / w) * 2 - 1; // [-1,1]
                    const ny = 1 - (py / h) * 2; // [1,-1]

                    const x = nx * aspect * scale + centerX;
                    const y = ny * scale + centerY;
                    return { x, y };
                }

                function saveLastViewImage() {
                    if (!lastImage) {
                        lastImage = document.createElement("canvas");
                    }
                    lastImage.width = canvas.width;
                    lastImage.height = canvas.height;
                    const lic = lastImage.getContext("2d");
                    lic.drawImage(canvas, 0, 0);
                    lastView.centerX = centerX;
                    lastView.centerY = centerY;
                    lastView.scale = scale;
                }

                function drawPreviewFromLastImage() {
                    if (!lastImage) return;
                    const width = canvas.width;
                    const height = canvas.height;
                    if (width === 0 || height === 0) return;

                    const aspect = width / height;

                    const fCenterX = lastView.centerX;
                    const fCenterY = lastView.centerY;
                    const fScale = lastView.scale;

                    // scale ratio old→new
                    const A = fScale / scale;

                    // solve for translation that maps old view to new view in screen space
                    const Bx =
                        (fCenterX * width -
                            centerX * width -
                            fScale * aspect * width +
                            scale * aspect * width) /
                        (2 * scale * aspect);

                    const By =
                        (-fCenterY * height +
                            centerY * height -
                            fScale * height +
                            scale * height) /
                        (2 * scale);

                    ctx.setTransform(A, 0, 0, A, Bx, By);
                    ctx.clearRect(0, 0, width, height);
                    ctx.drawImage(
                        lastImage,
                        0,
                        0,
                        lastImage.width,
                        lastImage.height,
                    );
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                function resetRender(options = {}) {
                    const { clear = false } = options;
                    renderId++;
                    currentStep = START_STEP;
                    tileX = 0;
                    tileY = 0;
                    if (clear) {
                        ctx.fillStyle = "black";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    updateInfo("rendering...");
                    requestAnimationFrame(() => renderLoop(renderId));
                }

                // --------- rendering ---------
                function renderLoop(id) {
                    if (id !== renderId) return; // outdated render

                    const w = canvas.width;
                    const h = canvas.height;
                    const aspect = w / h;
                    const escapeRadiusSq = 4.0;
                    const maxIter = maxIterForScale();

                    const TILES_PER_FRAME = 800; // adjust if needed
                    let tilesDone = 0;

                    while (tilesDone < TILES_PER_FRAME && currentStep >= 1) {
                        if (tileY >= h) {
                            // finished this step, go finer
                            currentStep = Math.floor(currentStep / 2);
                            if (currentStep < 1) break;
                            tileX = 0;
                            tileY = 0;
                            continue;
                        }

                        const step = currentStep;
                        const x = tileX;
                        const y = tileY;

                        // complex coord at center of tile
                        const cx = x + step * 0.5;
                        const cy = y + step * 0.5;
                        const nx = (cx / w) * 2 - 1;
                        const ny = 1 - (cy / h) * 2;

                        const x0 = nx * aspect * scale + centerX;
                        const y0 = ny * scale + centerY;

                        let zx = 0;
                        let zy = 0;
                        let iter = 0;
                        for (; iter < maxIter; iter++) {
                            const zx2 = zx * zx - zy * zy + x0;
                            const zy2 = 2 * zx * zy + y0;
                            zx = zx2;
                            zy = zy2;
                            if (zx * zx + zy * zy > escapeRadiusSq) break;
                        }

                        let gray;
                        if (iter === maxIter) {
                            gray = 0; // inside set: black
                        } else {
                            const t = iter / maxIter;
                            gray = Math.floor(255 * Math.sqrt(t)); // brighter near early escape
                        }

                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(x, y, step, step);

                        // advance tile
                        tileX += step;
                        if (tileX >= w) {
                            tileX = 0;
                            tileY += step;
                        }

                        tilesDone++;
                    }

                    if (currentStep >= 1) {
                        requestAnimationFrame(() => renderLoop(id));
                    } else {
                        updateInfo("done");
                        saveLastViewImage();
                    }
                }

                // --------- zooming ---------
                const ZOOM_SPEED = 0.0025;

                function zoomAt(clientX, clientY, zoomFactor) {
                    const rect = canvas.getBoundingClientRect();
                    const px = clientX - rect.left;
                    const py = clientY - rect.top;

                    // world coord before zoom
                    const before = pixelToComplex(px, py);

                    scale *= zoomFactor;

                    // world coord after zoom
                    const after = pixelToComplex(px, py);

                    // adjust center to keep point under cursor fixed
                    centerX += before.x - after.x;
                    centerY += before.y - after.y;

                    // warp old image as preview, then refine
                    drawPreviewFromLastImage();
                    resetRender({ clear: false });
                }

                canvas.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();
                        // restore original direction: deltaY > 0 → zoom OUT, < 0 → zoom IN
                        const zoomFactor = Math.exp(e.deltaY * ZOOM_SPEED);
                        zoomAt(e.clientX, e.clientY, zoomFactor);
                    },
                    { passive: false },
                );

                // --------- panning (mouse) ---------
                canvas.addEventListener("mousedown", (e) => {
                    isDragging = true;
                    canvas.classList.add("dragging");
                    lastX = e.clientX;
                    lastY = e.clientY;
                });

                window.addEventListener("mousemove", (e) => {
                    if (!isDragging) return;
                    const rect = canvas.getBoundingClientRect();
                    const w = rect.width;
                    const h = rect.height;
                    const aspect = w / h;

                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    lastX = e.clientX;
                    lastY = e.clientY;

                    const ndx = (dx / w) * 2;
                    const ndy = (dy / h) * 2;

                    // move center opposite of drag direction
                    centerX -= ndx * scale * aspect;
                    centerY += ndy * scale;

                    // warp old image as preview, then refine
                    drawPreviewFromLastImage();
                    resetRender({ clear: false });
                });

                window.addEventListener("mouseup", () => {
                    isDragging = false;
                    canvas.classList.remove("dragging");
                });

                // --------- basic touch support (1-finger pan, 2-finger pinch) ---------
                let touchDragging = false;
                let touchLastX = 0;
                let touchLastY = 0;
                let pinchActive = false;
                let lastPinchDist = 0;

                function touchDistance(t1, t2) {
                    const dx = t2.clientX - t1.clientX;
                    const dy = t2.clientY - t1.clientY;
                    return Math.hypot(dx, dy);
                }

                canvas.addEventListener(
                    "touchstart",
                    (e) => {
                        e.preventDefault();
                        if (e.touches.length === 1) {
                            touchDragging = true;
                            pinchActive = false;
                            const t = e.touches[0];
                            touchLastX = t.clientX;
                            touchLastY = t.clientY;
                        } else if (e.touches.length === 2) {
                            touchDragging = false;
                            pinchActive = true;
                            lastPinchDist = touchDistance(
                                e.touches[0],
                                e.touches[1],
                            );
                        }
                    },
                    { passive: false },
                );

                canvas.addEventListener(
                    "touchmove",
                    (e) => {
                        e.preventDefault();
                        if (pinchActive && e.touches.length === 2) {
                            const t1 = e.touches[0];
                            const t2 = e.touches[1];
                            const d = touchDistance(t1, t2);
                            if (d > 0 && lastPinchDist > 0) {
                                const zoomFactor = lastPinchDist / d;
                                const cx = (t1.clientX + t2.clientX) * 0.5;
                                const cy = (t1.clientY + t2.clientY) * 0.5;
                                zoomAt(cx, cy, zoomFactor);
                            }
                            lastPinchDist = d;
                        } else if (touchDragging && e.touches.length === 1) {
                            const t = e.touches[0];
                            const rect = canvas.getBoundingClientRect();
                            const w = rect.width;
                            const h = rect.height;
                            const aspect = w / h;

                            const dx = t.clientX - touchLastX;
                            const dy = t.clientY - touchLastY;
                            touchLastX = t.clientX;
                            touchLastY = t.clientY;

                            const ndx = (dx / w) * 2;
                            const ndy = (dy / h) * 2;

                            centerX -= ndx * scale * aspect;
                            centerY += ndy * scale;

                            drawPreviewFromLastImage();
                            resetRender({ clear: false });
                        }
                    },
                    { passive: false },
                );

                canvas.addEventListener(
                    "touchend",
                    (e) => {
                        e.preventDefault();
                        if (e.touches.length === 0) {
                            touchDragging = false;
                            pinchActive = false;
                        } else if (e.touches.length === 1) {
                            pinchActive = false;
                            const t = e.touches[0];
                            touchLastX = t.clientX;
                            touchLastY = t.clientY;
                            touchDragging = true;
                        }
                    },
                    { passive: false },
                );

                // --------- init ---------
                window.addEventListener("resize", () => {
                    resizeCanvas();
                });

                resizeCanvas();
                // first render: no previous image, so clear
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                resetRender({ clear: false });
            });
        </script>
    </body>
</html>
