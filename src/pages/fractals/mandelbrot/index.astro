<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Mandelbrot WASM (worker)</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #eee;
                font-family: system-ui, sans-serif;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
                display: block;
                touch-action: none;
                cursor: grab;
            }
            canvas:active {
                cursor: grabbing;
            }
            #controls {
                position: fixed;
                top: 10px;
                left: 10px;
                padding: 6px 8px;
                background: rgba(0, 0, 0, 0.75);
                border-radius: 6px;
                font-size: 12px;
                z-index: 10;
                user-select: none;
            }
            #controls label {
                display: flex;
                align-items: center;
                gap: 4px;
                margin-bottom: 4px;
            }
            #controls input[type="color"] {
                width: 20px;
                height: 20px;
                padding: 0;
                border: none;
                background: transparent;
            }
            #controls input[type="range"] {
                width: 140px;
            }
            #status {
                margin-top: 4px;
                opacity: 0.7;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco,
                    Consolas, "Liberation Mono", "Courier New", monospace;
            }
        </style>
    </head>
    <body>
        <canvas id="view"></canvas>

        <div id="controls">
            <div><strong>Palette</strong></div>
            <label>
                Color
                <input type="color" id="fc" />
            </label>
            <label>
                Glow
                <input type="range" id="bw" min="0" max="100" value="80" />
            </label>
            <label>
                <input type="checkbox" id="fillInside" checked="unchecked" />
                Fill interior
            </label>
            <div id="status">WASM worker loadingâ€¦</div>
        </div>

        <script>
            (function () {
                const canvas = document.getElementById("view");
                const ctx = canvas.getContext("2d");

                const fc = document.getElementById("fc");
                const bw = document.getElementById("bw");
                const status = document.getElementById("status");
                const fillInside = document.getElementById("fillInside");

                fc.value = "#00ffff";

                let fillInterior = 0;

                let centerX = -0.75;
                let centerY = 0.0;
                let zoom = 1.0;

                let fullW = 0;
                let fullH = 0;

                const baseCanvas = document.createElement("canvas");
                const baseCtx = baseCanvas.getContext("2d");
                let baseValid = false;

                const bufCanvas = document.createElement("canvas");
                const bufCtx = bufCanvas.getContext("2d");

                let viewScale = 1;
                let viewOffsetX = 0;
                let viewOffsetY = 0;

                let worker = null;
                let workerReady = false;
                let nextJobId = 1;
                let currentJobId = null;
                let jobInFlight = false;

                let lastGray = null;
                let lastFbW = 0;
                let lastFbH = 0;

                const STAGES = [
                    { scale: 64 },
                    { scale: 32 },
                    { scale: 16 },
                    { scale: 8 },
                    { scale: 4 },
                    { scale: 2 },
                    { scale: 0.25 },
                ];

                let currentStage = -1;
                let stagePending = false;

                let interactionActive = false;
                let lastInteractionTime = 0;
                const INTERACTION_SETTLE_MS = 50;

                let isPanning = false;
                let panStartX = 0;
                let panStartY = 0;
                let panStartCenterX = 0;
                let panStartCenterY = 0;

                function setStatus(msg) {
                    status.textContent = msg;
                }

                function hexToRgb(hex) {
                    let h = hex.replace("#", "");
                    if (h.length === 3) {
                        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
                    }
                    const num = parseInt(h, 16);
                    return {
                        r: (num >> 16) & 255,
                        g: (num >> 8) & 255,
                        b: num & 255,
                    };
                }

                function getBandWidth() {
                    const raw = parseInt(bw.value, 10) || 0;
                    const sNorm = Math.min(1, Math.max(0, raw / 100));
                    const sInv = 1 - sNorm;
                    const minW = 0.1;
                    const maxW = 0.95;
                    return minW + sInv * (maxW - minW);
                }

                function currentWorldParams() {
                    if (!fullW || !fullH) {
                        return {
                            worldWidth: 0,
                            worldHeight: 0,
                            worldX0: centerX,
                            worldY0: centerY,
                        };
                    }
                    const minDim = Math.min(fullW, fullH);
                    const basePixelSize = 4.0 / minDim;
                    const pixelSize = basePixelSize / zoom;

                    const worldWidth = pixelSize * fullW;
                    const worldHeight = pixelSize * fullH;

                    const worldX0 = centerX - worldWidth / 2;
                    const worldY0 = centerY - worldHeight / 2;

                    return { worldWidth, worldHeight, worldX0, worldY0 };
                }

                function screenToWorld(sx, sy) {
                    const { worldWidth, worldHeight, worldX0, worldY0 } =
                        currentWorldParams();
                    if (!fullW || !fullH) {
                        return { cx: centerX, cy: centerY };
                    }
                    const u = sx / fullW;
                    const v = sy / fullH;
                    const cx = worldX0 + u * worldWidth;
                    const cy = worldY0 + v * worldHeight;
                    return { cx, cy };
                }

                function resize() {
                    const cssW = window.innerWidth;
                    const cssH = window.innerHeight;

                    canvas.style.width = cssW + "px";
                    canvas.style.height = cssH + "px";

                    canvas.width = cssW;
                    canvas.height = cssH;

                    fullW = canvas.width;
                    fullH = canvas.height;

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;

                    baseValid = false;
                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    lastGray = null;

                    if (workerReady) {
                        requestFullRender();
                    }
                }

                window.addEventListener("resize", () => {
                    resize();
                    markInteraction();
                });

                function markInteraction() {
                    interactionActive = true;
                    lastInteractionTime = performance.now();

                    stagePending = false;
                    currentStage = -1;

                    if (workerReady && currentJobId != null) {
                        worker.postMessage({
                            type: "cancel",
                            jobId: currentJobId,
                        });
                    }
                    currentJobId = null;
                    jobInFlight = false;
                }

                function requestFullRender() {
                    if (!workerReady) return;
                    currentStage = 0;
                    stagePending = true;
                }

                function colorizeGray(gray, w, h) {
                    const N = gray.length;
                    const out = new Uint8ClampedArray(N * 4);

                    const color = hexToRgb(fc.value);
                    const bandWidth = getBandWidth();

                    let o = 0;
                    for (let i = 0; i < N; i++) {
                        const gNorm = gray[i] / 255;
                        let r, g, b;

                        if (gNorm <= 0) {
                            r = g = b = 0;
                        } else {
                            let wVal;
                            if (gNorm >= bandWidth) wVal = 1;
                            else wVal = gNorm / bandWidth;

                            r = color.r * wVal;
                            g = color.g * wVal;
                            b = color.b * wVal;
                        }

                        out[o++] = r;
                        out[o++] = g;
                        out[o++] = b;
                        out[o++] = 255;
                    }
                    return out;
                }

                function applyPaletteToLastGray() {
                    if (!lastGray || lastFbW <= 0 || lastFbH <= 0) return;

                    const colored = colorizeGray(lastGray, lastFbW, lastFbH);

                    bufCanvas.width = lastFbW;
                    bufCanvas.height = lastFbH;
                    const img = new ImageData(colored, lastFbW, lastFbH);
                    bufCtx.putImageData(img, 0, 0);

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;
                    baseCtx.setTransform(1, 0, 0, 1, 0, 0);
                    baseCtx.clearRect(0, 0, fullW, fullH);
                    baseCtx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        lastFbW,
                        lastFbH,
                        0,
                        0,
                        fullW,
                        fullH,
                    );
                    baseValid = true;

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(baseCanvas, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                canvas.addEventListener("pointerdown", (e) => {
                    isPanning = true;
                    canvas.setPointerCapture(e.pointerId);
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    panStartCenterX = centerX;
                    panStartCenterY = centerY;
                });

                canvas.addEventListener("pointermove", (e) => {
                    if (!isPanning) return;
                    const dx = e.clientX - panStartX;
                    const dy = e.clientY - panStartY;

                    const { worldWidth, worldHeight } = currentWorldParams();

                    if (worldWidth && worldHeight) {
                        centerX =
                            panStartCenterX -
                            (dx / (window.innerWidth || 1)) * worldWidth;
                        centerY =
                            panStartCenterY -
                            (dy / (window.innerHeight || 1)) * worldHeight;
                    }

                    viewOffsetX = dx;
                    viewOffsetY = dy;

                    markInteraction();
                });

                function endPan(e) {
                    if (!isPanning) return;
                    isPanning = false;
                    try {
                        canvas.releasePointerCapture(e.pointerId);
                    } catch (_) {}
                    markInteraction();
                }

                canvas.addEventListener("pointerup", endPan);
                canvas.addEventListener("pointercancel", endPan);

                canvas.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();

                        const rect = canvas.getBoundingClientRect();
                        const sx = e.clientX - rect.left;
                        const sy = e.clientY - rect.top;

                        const before = screenToWorld(sx, sy);

                        const delta = -e.deltaY;
                        const zoomFactor = Math.exp(delta * 0.001);
                        zoom *= zoomFactor;

                        const after = screenToWorld(sx, sy);
                        centerX += before.cx - after.cx;
                        centerY += before.cy - after.cy;

                        const oldScale = viewScale;
                        const newScale = viewScale * zoomFactor;

                        viewOffsetX =
                            sx - (sx - viewOffsetX) * (newScale / oldScale);
                        viewOffsetY =
                            sy - (sy - viewOffsetY) * (newScale / oldScale);
                        viewScale = newScale;

                        markInteraction();
                    },
                    { passive: false },
                );

                fc.addEventListener("input", applyPaletteToLastGray);
                bw.addEventListener("input", applyPaletteToLastGray);

                fillInside.addEventListener("change", () => {
                    fillInterior = fillInside.checked ? 1 : 0;

                    if (workerReady && currentJobId != null) {
                        worker.postMessage({
                            type: "cancel",
                            jobId: currentJobId,
                        });
                    }
                    currentJobId = null;
                    jobInFlight = false;
                    currentStage = -1;
                    stagePending = false;

                    interactionActive = false;
                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    requestFullRender();
                });

                function drawInteractiveFrame() {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);

                    if (!baseValid) return;

                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(baseCanvas, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                function drawStableBase() {
                    if (!baseValid) return;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(baseCanvas, 0, 0);
                }

                function startWorkerJob(stageIndex) {
                    if (!workerReady) return;
                    const stage = STAGES[stageIndex];
                    const scale = stage.scale;

                    const fbW = fullW;
                    const fbH = fullH;
                    if (!fbW || !fbH) return;

                    const jobId = nextJobId++;
                    currentJobId = jobId;
                    jobInFlight = true;

                    const cxSnap = centerX;
                    const cySnap = centerY;
                    const zoomSnap = zoom;
                    const scaleSnap = scale;
                    const fillSnap = fillInterior | 0;

                    worker.postMessage({
                        type: "render",
                        jobId,
                        fbW,
                        fbH,
                        cx: cxSnap,
                        cy: cySnap,
                        zoom: zoomSnap,
                        scale: scaleSnap,
                        fillInterior: fillSnap,
                    });

                    setStatus(
                        `stage=${stageIndex} scale=${scaleSnap} fb=${fbW}x${fbH}`,
                    );
                }

                function handleWorkerPartial(msg) {
                    const { jobId, fbW, fbH, gray, yStart, yEnd } = msg;

                    if (currentJobId === null || jobId !== currentJobId) {
                        return;
                    }

                    const numRows = yEnd - yStart;
                    if (numRows <= 0) return;

                    if (!lastGray || lastFbW !== fbW || lastFbH !== fbH) {
                        lastGray = new Uint8Array(fbW * fbH);
                        lastFbW = fbW;
                        lastFbH = fbH;
                    }

                    for (let row = 0; row < numRows; row++) {
                        const srcBase = row * fbW;
                        const dstRow = yStart + row;
                        const dstBase = dstRow * fbW;
                        lastGray.set(
                            gray.subarray(srcBase, srcBase + fbW),
                            dstBase,
                        );
                    }

                    const coloredBand = colorizeGray(gray, fbW, numRows);

                    bufCanvas.width = fbW;
                    bufCanvas.height = numRows;
                    const img = new ImageData(coloredBand, fbW, numRows);
                    bufCtx.putImageData(img, 0, 0);

                    const destY = (yStart / fbH) * fullH;
                    const destH = (numRows / fbH) * fullH;

                    ctx.setTransform(1, 0, 0, 1, 0, 0);

                    // colored leading band across whole width
                    ctx.fillStyle = fc.value;
                    ctx.fillRect(0, destY, fullW, destH);

                    // overlay detailed band
                    ctx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        fbW,
                        numRows,
                        0,
                        destY,
                        fullW,
                        destH,
                    );
                }

                function handleWorkerFrame(msg) {
                    const { jobId, fbW, fbH, gray, scale: jobScale } = msg;

                    if (currentJobId === null || jobId !== currentJobId) {
                        jobInFlight = false;
                        return;
                    }

                    jobInFlight = false;

                    lastGray = new Uint8Array(gray);
                    lastFbW = fbW;
                    lastFbH = fbH;

                    const colored = colorizeGray(lastGray, fbW, fbH);

                    bufCanvas.width = fbW;
                    bufCanvas.height = fbH;
                    const img = new ImageData(colored, fbW, fbH);
                    bufCtx.putImageData(img, 0, 0);

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        fbW,
                        fbH,
                        0,
                        0,
                        fullW,
                        fullH,
                    );

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;
                    baseCtx.clearRect(0, 0, fullW, fullH);
                    baseCtx.drawImage(canvas, 0, 0);
                    baseValid = true;

                    setStatus(`done stage=${currentStage} scale=${jobScale}`);

                    currentStage++;
                    stagePending = currentStage < STAGES.length;
                    if (!stagePending) {
                        currentStage = -1;
                        setStatus("idle");
                    }
                }

                function loop() {
                    const now = performance.now();

                    if (
                        interactionActive &&
                        !isPanning &&
                        now - lastInteractionTime > INTERACTION_SETTLE_MS &&
                        currentStage === -1 &&
                        workerReady
                    ) {
                        interactionActive = false;
                        viewScale = 1;
                        viewOffsetX = 0;
                        viewOffsetY = 0;
                        requestFullRender();
                    }

                    if (interactionActive) {
                        drawInteractiveFrame();
                    } else if (stagePending && !jobInFlight) {
                        startWorkerJob(currentStage);
                    } else if (
                        !interactionActive &&
                        !stagePending &&
                        !jobInFlight
                    ) {
                        drawStableBase();
                    }

                    requestAnimationFrame(loop);
                }

                function initWorker() {
                    // worker script in public/
                    worker = new Worker("/mandel-worker.js");
                    worker.onmessage = (e) => {
                        const msg = e.data;
                        if (msg.type === "ready") {
                            workerReady = true;
                            setStatus("worker ready");
                            resize();
                            requestFullRender();
                            return;
                        }
                        if (msg.type === "partial") {
                            handleWorkerPartial(msg);
                            return;
                        }
                        if (msg.type === "frame") {
                            handleWorkerFrame(msg);
                            return;
                        }
                    };
                }

                function init() {
                    initWorker();
                    loop();
                }

                init();
            })();
        </script>
    </body>
</html>
