<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Mandelbrot WASM (worker)</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #eee;
                font-family: system-ui, sans-serif;
                overflow: hidden;
            }

            #app {
                height: 100vh;
                display: flex;
                flex-direction: column;
            }

            #canvasWrapper {
                position: relative;
                flex: 1 1 auto;
                overflow: hidden;
            }

            canvas {
                width: 100%;
                height: 100%;
                display: block;
                touch-action: none;
                cursor: grab;
            }
            canvas:active {
                cursor: grabbing;
            }

            /* Palette / controls box */
            #controls {
                position: fixed;
                top: 16px;
                left: 16px;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.75);
                border-radius: 4px;
                border: 1px solid transparent; /* updated from JS to match palette color */
                font-size: 12px;
                z-index: 10;
                user-select: none;
                box-shadow: 0 0 4px rgba(0, 0, 0, 0.6);
            }

            #controlsHeader {
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.03em;
                margin-bottom: 6px;
                cursor: move; /* drag handle */
            }

            #controls .controls-row {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 4px;
            }

            #controls label {
                display: flex;
                align-items: center;
                gap: 4px;
                margin: 0;
            }

            #controls input[type="color"] {
                width: 26px;
                height: 26px;
                padding: 0;
                border-radius: 2px;
                border: 1px solid #555;
                background: #111;
                box-sizing: border-box;
            }

            #controls input[type="checkbox"] {
                margin: 0;
            }

            #controls input[type="range"] {
                width: 160px;
                margin: 2px 0 0 0;
                border-radius: 2px;
            }

            /* Bottom status bar */
            #statusBar {
                flex: 0 0 auto;
                height: 26px;
                padding: 4px 8px;
                background: #050505;
                border-top: 1px solid #222;
                font-size: 11px;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco,
                    Consolas, "Liberation Mono", "Courier New", monospace;
                display: flex;
                align-items: center;
                white-space: nowrap;
                overflow: hidden;
                opacity: 0.8;
                gap: 8px;
            }

            #backLink {
                text-decoration: underline;
                color: #00ffff; /* updated from JS to match palette color */
                cursor: pointer;
                white-space: nowrap;
                flex: 0 0 auto;
            }

            #status {
                flex: 1 1 auto;
                overflow: hidden;
                text-overflow: ellipsis;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <div id="canvasWrapper">
                <canvas id="view"></canvas>

                <div id="controls">
                    <div id="controlsHeader">Palette</div>
                    <div class="controls-row">
                        <label>
                            Color
                            <input type="color" id="fc" />
                        </label>
                        <label>
                            <input type="checkbox" id="fillInside" checked />
                            Fill interior
                        </label>
                    </div>
                    <div class="controls-row">
                        <label style="flex: 1 1 auto">
                            Glow
                            <input
                                type="range"
                                id="bw"
                                min="0"
                                max="100"
                                value="80"
                            />
                        </label>
                    </div>
                </div>
            </div>

            <div id="statusBar">
                <a id="backLink" href="../">back</a>
                <div id="status">WASM worker loading…</div>
            </div>
        </div>

        <script>
            (function () {
                const canvas = document.getElementById("view");
                const ctx = canvas.getContext("2d");

                const controls = document.getElementById("controls");
                const controlsHeader =
                    document.getElementById("controlsHeader");

                const fc = document.getElementById("fc");
                const bw = document.getElementById("bw");
                const statusEl = document.getElementById("status");
                const fillInside = document.getElementById("fillInside");
                const backLink = document.getElementById("backLink");

                fc.value = "#00ffff";

                // status state
                let statusRender = "WASM worker loading…";
                let statusCursor = "";
                let statusZoom = "";
                let statusError = "";

                function updateStatus() {
                    const parts = [];
                    if (statusRender) parts.push(statusRender);
                    if (statusCursor) parts.push(statusCursor);
                    if (statusZoom) parts.push(statusZoom);
                    if (statusError) parts.push(statusError);
                    statusEl.textContent = parts.join(" | ");
                }

                function setRenderStatus(msg) {
                    statusRender = msg;
                    updateStatus();
                }

                function setZoomStatus() {
                    statusZoom = `zoom: ${zoom.toFixed(3)}x`;
                    updateStatus();
                }

                function setCursorStatus(cx, cy) {
                    if (cx == null || cy == null) {
                        statusCursor = "";
                        updateStatus();
                        return;
                    }
                    const re = cx.toFixed(6);
                    const imAbs = Math.abs(cy).toFixed(6);
                    const sign = cy >= 0 ? "+" : "-";
                    statusCursor = `cursor: ${re} ${sign} ${imAbs}i`;
                    updateStatus();
                }

                function setErrorStatus(msg) {
                    statusError = msg ? `error: ${msg}` : "";
                    updateStatus();
                }

                // initialize from checkbox state so it's respected on first render
                let fillInterior = fillInside.checked ? 1 : 0;

                let centerX = -0.75;
                let centerY = 0.0;
                let zoom = 1.0;

                let fullW = 0;
                let fullH = 0;

                const baseCanvas = document.createElement("canvas");
                const baseCtx = baseCanvas.getContext("2d");
                let baseValid = false;

                const bufCanvas = document.createElement("canvas");
                const bufCtx = bufCanvas.getContext("2d");

                let viewScale = 1;
                let viewOffsetX = 0;
                let viewOffsetY = 0;

                let worker = null;
                let workerReady = false;
                let nextJobId = 1;
                let currentJobId = null;
                let jobInFlight = false;

                let lastGray = null;
                let lastFbW = 0;
                let lastFbH = 0;

                const STAGES = [
                    { scale: 64 },
                    { scale: 32 },
                    { scale: 16 },
                    { scale: 8 },
                    { scale: 4 },
                    { scale: 2 },
                    { scale: 0.25 },
                ];

                let currentStage = -1;
                let stagePending = false;

                let interactionActive = false;
                let lastInteractionTime = 0;
                const INTERACTION_SETTLE_MS = 50;

                let isPanning = false;
                let panStartX = 0;
                let panStartY = 0;
                let panStartCenterX = 0;
                let panStartCenterY = 0;

                // drag for controls (via header only)
                let draggingControls = false;
                let dragOffsetX = 0;
                let dragOffsetY = 0;

                // pinch-zoom state
                const activePointers = new Map(); // id -> {x, y}
                let isPinching = false;
                let pinchStartDist = 0;
                let pinchStartZoom = 1;
                let pinchStartWorldX = 0;
                let pinchStartWorldY = 0;
                let pinchLastZoomFactor = 1;

                function hexToRgb(hex) {
                    let h = hex.replace("#", "");
                    if (h.length === 3) {
                        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
                    }
                    const num = parseInt(h, 16);
                    return {
                        r: (num >> 16) & 255,
                        g: (num >> 8) & 255,
                        b: num & 255,
                    };
                }

                function getBandWidth() {
                    const raw = parseInt(bw.value, 10) || 0;
                    const sNorm = Math.min(1, Math.max(0, raw / 100));
                    const sInv = 1 - sNorm;
                    const minW = 0.1;
                    const maxW = 0.95;
                    return minW + sInv * (maxW - minW);
                }

                function currentWorldParams() {
                    if (!fullW || !fullH) {
                        return {
                            worldWidth: 0,
                            worldHeight: 0,
                            worldX0: centerX,
                            worldY0: centerY,
                        };
                    }
                    const minDim = Math.min(fullW, fullH);
                    const basePixelSize = 4.0 / minDim;
                    const pixelSize = basePixelSize / zoom;

                    const worldWidth = pixelSize * fullW;
                    const worldHeight = pixelSize * fullH;

                    const worldX0 = centerX - worldWidth / 2;
                    const worldY0 = centerY - worldHeight / 2;

                    return { worldWidth, worldHeight, worldX0, worldY0 };
                }

                function screenToWorld(sx, sy) {
                    const { worldWidth, worldHeight, worldX0, worldY0 } =
                        currentWorldParams();
                    if (!fullW || !fullH) {
                        return { cx: centerX, cy: centerY };
                    }
                    const u = sx / fullW;
                    const v = sy / fullH;
                    const cx = worldX0 + u * worldWidth;
                    const cy = worldY0 + v * worldHeight;
                    return { cx, cy };
                }

                function resize() {
                    const rect = canvas.getBoundingClientRect();
                    const cssW = rect.width;
                    const cssH = rect.height;

                    const newW = Math.max(1, Math.floor(cssW));
                    const newH = Math.max(1, Math.floor(cssH));

                    canvas.width = newW;
                    canvas.height = newH;

                    fullW = newW;
                    fullH = newH;

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;

                    baseValid = false;
                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    lastGray = null;

                    if (workerReady) {
                        requestFullRender();
                    }
                }

                window.addEventListener("resize", () => {
                    resize();
                    markInteraction();
                });

                function markInteraction() {
                    interactionActive = true;
                    lastInteractionTime = performance.now();

                    stagePending = false;
                    currentStage = -1;

                    if (workerReady && currentJobId != null) {
                        worker.postMessage({
                            type: "cancel",
                            jobId: currentJobId,
                        });
                    }
                    currentJobId = null;
                    jobInFlight = false;
                }

                function requestFullRender() {
                    if (!workerReady) return;
                    currentStage = 0;
                    stagePending = true;
                    setErrorStatus("");
                }

                function colorizeGray(gray, w, h) {
                    const N = gray.length;
                    const out = new Uint8ClampedArray(N * 4);

                    const color = hexToRgb(fc.value);
                    const bandWidth = getBandWidth();

                    let o = 0;
                    for (let i = 0; i < N; i++) {
                        const gNorm = gray[i] / 255;
                        let r, g, b;

                        if (gNorm <= 0) {
                            r = g = b = 0;
                        } else {
                            let wVal;
                            if (gNorm >= bandWidth) wVal = 1;
                            else wVal = gNorm / bandWidth;

                            r = color.r * wVal;
                            g = color.g * wVal;
                            b = color.b * wVal;
                        }

                        out[o++] = r;
                        out[o++] = g;
                        out[o++] = b;
                        out[o++] = 255;
                    }
                    return out;
                }

                function applyPaletteToLastGray() {
                    if (!lastGray || lastFbW <= 0 || lastFbH <= 0) return;

                    const colored = colorizeGray(lastGray, lastFbW, lastFbH);

                    bufCanvas.width = lastFbW;
                    bufCanvas.height = lastFbH;
                    const img = new ImageData(colored, lastFbW, lastFbH);
                    bufCtx.putImageData(img, 0, 0);

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;
                    baseCtx.setTransform(1, 0, 0, 1, 0, 0);
                    baseCtx.clearRect(0, 0, fullW, fullH);
                    baseCtx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        lastFbW,
                        lastFbH,
                        0,
                        0,
                        fullW,
                        fullH,
                    );
                    baseValid = true;

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(baseCanvas, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                function updatePaletteBorderColor() {
                    controls.style.borderColor = fc.value;
                    backLink.style.color = fc.value;
                }

                // canvas pointer / touch interactions
                canvas.addEventListener("pointerdown", (e) => {
                    activePointers.set(e.pointerId, {
                        x: e.clientX,
                        y: e.clientY,
                    });

                    // start pinch when we have 2 pointers
                    if (activePointers.size === 2) {
                        isPinching = true;
                        isPanning = false;

                        const pts = Array.from(activePointers.values());
                        const dx = pts[0].x - pts[1].x;
                        const dy = pts[0].y - pts[1].y;
                        pinchStartDist = Math.hypot(dx, dy) || 1;
                        pinchStartZoom = zoom;
                        pinchLastZoomFactor = 1;

                        const rect = canvas.getBoundingClientRect();
                        const sx = (pts[0].x + pts[1].x) / 2 - rect.left;
                        const sy = (pts[0].y + pts[1].y) / 2 - rect.top;

                        const world = screenToWorld(sx, sy);
                        pinchStartWorldX = world.cx;
                        pinchStartWorldY = world.cy;

                        markInteraction();
                        return;
                    }

                    // single-finger pan
                    if (!isPinching && activePointers.size === 1) {
                        isPanning = true;
                        canvas.setPointerCapture(e.pointerId);
                        panStartX = e.clientX;
                        panStartY = e.clientY;
                        panStartCenterX = centerX;
                        panStartCenterY = centerY;
                    }
                });

                canvas.addEventListener("pointermove", (e) => {
                    if (!activePointers.has(e.pointerId)) return;
                    activePointers.set(e.pointerId, {
                        x: e.clientX,
                        y: e.clientY,
                    });

                    const rect = canvas.getBoundingClientRect();
                    const sx = e.clientX - rect.left;
                    const sy = e.clientY - rect.top;

                    const world = screenToWorld(sx, sy);
                    setCursorStatus(world.cx, world.cy);

                    if (isPinching && activePointers.size === 2) {
                        const pts = Array.from(activePointers.values());
                        const dx = pts[0].x - pts[1].x;
                        const dy = pts[0].y - pts[1].y;
                        const dist = Math.hypot(dx, dy) || 1;
                        const zoomFactor = dist / pinchStartDist;

                        zoom = pinchStartZoom * zoomFactor;

                        const sxNow = (pts[0].x + pts[1].x) / 2 - rect.left;
                        const syNow = (pts[0].y + pts[1].y) / 2 - rect.top;

                        const after = screenToWorld(sxNow, syNow);
                        centerX += pinchStartWorldX - after.cx;
                        centerY += pinchStartWorldY - after.cy;

                        // adjust interactive viewScale/offset like wheel zoom
                        const relative =
                            zoomFactor / (pinchLastZoomFactor || 1);
                        const oldScale = viewScale || 1;
                        const newScale = oldScale * relative;

                        viewOffsetX =
                            sxNow -
                            (sxNow - viewOffsetX) * (newScale / oldScale);
                        viewOffsetY =
                            syNow -
                            (syNow - viewOffsetY) * (newScale / oldScale);
                        viewScale = newScale;

                        pinchLastZoomFactor = zoomFactor;

                        setZoomStatus();
                        markInteraction();
                        return;
                    }

                    if (!isPanning || isPinching) return;

                    const dx = e.clientX - panStartX;
                    const dy = e.clientY - panStartY;

                    const { worldWidth, worldHeight } = currentWorldParams();

                    if (worldWidth && worldHeight) {
                        centerX =
                            panStartCenterX - (dx / (fullW || 1)) * worldWidth;
                        centerY =
                            panStartCenterY - (dy / (fullH || 1)) * worldHeight;
                    }

                    viewOffsetX = dx;
                    viewOffsetY = dy;

                    markInteraction();
                });

                canvas.addEventListener("pointerleave", () => {
                    setCursorStatus(null, null);
                });

                function endPan(e) {
                    if (activePointers.has(e.pointerId)) {
                        activePointers.delete(e.pointerId);
                    }

                    if (isPinching && activePointers.size < 2) {
                        isPinching = false;
                        pinchLastZoomFactor = 1;
                    }

                    if (!isPanning) return;
                    isPanning = false;
                    try {
                        canvas.releasePointerCapture(e.pointerId);
                    } catch (_) {}
                    markInteraction();
                }

                canvas.addEventListener("pointerup", endPan);
                canvas.addEventListener("pointercancel", endPan);

                // mouse wheel zoom
                canvas.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();

                        const rect = canvas.getBoundingClientRect();
                        const sx = e.clientX - rect.left;
                        const sy = e.clientY - rect.top;

                        const before = screenToWorld(sx, sy);

                        const delta = -e.deltaY;
                        const zoomFactor = Math.exp(delta * 0.001);
                        zoom *= zoomFactor;

                        const after = screenToWorld(sx, sy);
                        centerX += before.cx - after.cx;
                        centerY += before.cy - after.cy;

                        const oldScale = viewScale || 1;
                        const newScale = oldScale * zoomFactor;

                        viewOffsetX =
                            sx - (sx - viewOffsetX) * (newScale / oldScale);
                        viewOffsetY =
                            sy - (sy - viewOffsetY) * (newScale / oldScale);
                        viewScale = newScale;

                        setZoomStatus();
                        markInteraction();
                    },
                    { passive: false },
                );

                // palette events
                fc.addEventListener("input", () => {
                    updatePaletteBorderColor();
                    applyPaletteToLastGray();
                });
                bw.addEventListener("input", applyPaletteToLastGray);

                fillInside.addEventListener("change", () => {
                    fillInterior = fillInside.checked ? 1 : 0;

                    if (workerReady && currentJobId != null) {
                        worker.postMessage({
                            type: "cancel",
                            jobId: currentJobId,
                        });
                    }
                    currentJobId = null;
                    jobInFlight = false;
                    currentStage = -1;
                    stagePending = false;

                    interactionActive = false;
                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    requestFullRender();
                });

                function drawInteractiveFrame() {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);

                    if (!baseValid) return;

                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(baseCanvas, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                function drawStableBase() {
                    if (!baseValid) return;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(baseCanvas, 0, 0);
                }

                function startWorkerJob(stageIndex) {
                    if (!workerReady) return;
                    const stage = STAGES[stageIndex];
                    const scale = stage.scale;

                    const fbW = fullW;
                    const fbH = fullH;
                    if (!fbW || !fbH) return;

                    const jobId = nextJobId++;
                    currentJobId = jobId;
                    jobInFlight = true;

                    const cxSnap = centerX;
                    const cySnap = centerY;
                    const zoomSnap = zoom;
                    const scaleSnap = scale;
                    const fillSnap = fillInterior | 0;

                    worker.postMessage({
                        type: "render",
                        jobId,
                        fbW,
                        fbH,
                        cx: cxSnap,
                        cy: cySnap,
                        zoom: zoomSnap,
                        scale: scaleSnap,
                        fillInterior: fillSnap,
                    });

                    setRenderStatus(
                        `render: stage ${stageIndex + 1}/${STAGES.length} scale=${scaleSnap}`,
                    );
                }

                // solid scan band in palette color for upcoming rows
                function handleWorkerScan(msg) {
                    const { jobId, fbW, fbH, yStart, yEnd } = msg;
                    if (currentJobId === null || jobId !== currentJobId) return;

                    const numRows = yEnd - yStart;
                    if (numRows <= 0) return;

                    const destY = (yStart / fbH) * fullH;
                    const destH = (numRows / fbH) * fullH;

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.fillStyle = fc.value; // same as palette color
                    ctx.fillRect(0, destY, fullW, destH);
                }

                function handleWorkerPartial(msg) {
                    const { jobId, fbW, fbH, gray, yStart, yEnd } = msg;

                    if (currentJobId === null || jobId !== currentJobId) {
                        return;
                    }

                    const numRows = yEnd - yStart;
                    if (numRows <= 0) return;

                    if (!lastGray || lastFbW !== fbW || lastFbH !== fbH) {
                        lastGray = new Uint8Array(fbW * fbH);
                        lastFbW = fbW;
                        lastFbH = fbH;
                    }

                    for (let row = 0; row < numRows; row++) {
                        const srcBase = row * fbW;
                        const dstRow = yStart + row;
                        const dstBase = dstRow * fbW;
                        lastGray.set(
                            gray.subarray(srcBase, srcBase + fbW),
                            dstBase,
                        );
                    }

                    const coloredBand = colorizeGray(gray, fbW, numRows);

                    bufCanvas.width = fbW;
                    bufCanvas.height = numRows;
                    const img = new ImageData(coloredBand, fbW, numRows);
                    bufCtx.putImageData(img, 0, 0);

                    const destY = (yStart / fbH) * fullH;
                    const destH = (numRows / fbH) * fullH;

                    ctx.setTransform(1, 0, 0, 1, 0, 0);

                    // draw the detailed band (this overwrites the scan band for these rows)
                    ctx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        fbW,
                        numRows,
                        0,
                        destY,
                        fullW,
                        destH,
                    );
                }

                function handleWorkerFrame(msg) {
                    const { jobId, fbW, fbH, gray, scale: jobScale } = msg;

                    if (currentJobId === null || jobId !== currentJobId) {
                        jobInFlight = false;
                        return;
                    }

                    jobInFlight = false;

                    lastGray = new Uint8Array(gray);
                    lastFbW = fbW;
                    lastFbH = fbH;

                    const colored = colorizeGray(lastGray, fbW, fbH);

                    bufCanvas.width = fbW;
                    bufCanvas.height = fbH;
                    const img = new ImageData(colored, fbW, fbH);
                    bufCtx.putImageData(img, 0, 0);

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        fbW,
                        fbH,
                        0,
                        0,
                        fullW,
                        fullH,
                    );

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;
                    baseCtx.clearRect(0, 0, fullW, fullH);
                    baseCtx.drawImage(canvas, 0, 0);
                    baseValid = true;

                    currentStage++;
                    stagePending = currentStage < STAGES.length;
                    if (!stagePending) {
                        currentStage = -1;
                        setRenderStatus("idle");
                    } else {
                        setRenderStatus(
                            `render: stage ${currentStage + 1}/${
                                STAGES.length
                            } scale=${STAGES[currentStage].scale}`,
                        );
                    }
                }

                function loop() {
                    const now = performance.now();

                    if (
                        interactionActive &&
                        !isPanning &&
                        !isPinching &&
                        now - lastInteractionTime > INTERACTION_SETTLE_MS &&
                        currentStage === -1 &&
                        workerReady
                    ) {
                        interactionActive = false;
                        viewScale = 1;
                        viewOffsetX = 0;
                        requestFullRender();
                    }

                    if (interactionActive) {
                        drawInteractiveFrame();
                    } else if (stagePending && !jobInFlight) {
                        startWorkerJob(currentStage);
                    } else if (
                        !interactionActive &&
                        !stagePending &&
                        !jobInFlight
                    ) {
                        drawStableBase();
                    }

                    requestAnimationFrame(loop);
                }

                function initWorker() {
                    worker = new Worker("/mandel-worker.js");
                    worker.onmessage = (e) => {
                        const msg = e.data;
                        if (msg.type === "ready") {
                            workerReady = true;
                            setRenderStatus("worker ready");
                            setErrorStatus("");
                            requestFullRender();
                            return;
                        }
                        if (msg.type === "scan") {
                            handleWorkerScan(msg);
                            return;
                        }
                        if (msg.type === "partial") {
                            handleWorkerPartial(msg);
                            return;
                        }
                        if (msg.type === "frame") {
                            handleWorkerFrame(msg);
                            return;
                        }
                        if (msg.type === "error") {
                            setErrorStatus(msg.message || "worker error");
                            return;
                        }
                    };
                    worker.onerror = (err) => {
                        setErrorStatus(err.message || "worker error");
                    };
                    worker.onmessageerror = () => {
                        setErrorStatus("worker message error");
                    };
                }

                // drag controls via header
                controlsHeader.addEventListener("pointerdown", (e) => {
                    if (e.button !== 0) return;
                    draggingControls = true;
                    controlsHeader.setPointerCapture(e.pointerId);
                    const rect = controls.getBoundingClientRect();
                    dragOffsetX = e.clientX - rect.left;
                    dragOffsetY = e.clientY - rect.top;
                });

                function endControlsDrag(e) {
                    if (!draggingControls) return;
                    draggingControls = false;
                    try {
                        controlsHeader.releasePointerCapture(e.pointerId);
                    } catch (_) {}
                }

                window.addEventListener("pointermove", (e) => {
                    if (!draggingControls) return;
                    const x = e.clientX - dragOffsetX;
                    const y = e.clientY - dragOffsetY;
                    controls.style.left = x + "px";
                    controls.style.top = y + "px";
                });

                controlsHeader.addEventListener("pointerup", endControlsDrag);
                controlsHeader.addEventListener(
                    "pointercancel",
                    endControlsDrag,
                );

                function init() {
                    resize();
                    updatePaletteBorderColor();
                    setZoomStatus();
                    updateStatus();
                    initWorker();
                    loop();
                }

                init();
            })();
        </script>
    </body>
</html>
