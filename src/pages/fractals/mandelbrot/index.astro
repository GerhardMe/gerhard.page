<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Mandelbrot WASM (JS pan/zoom + grayscale + JS palette)</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #eee;
                font-family: system-ui, sans-serif;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
                display: block;
                touch-action: none;
                cursor: grab;
            }
            canvas:active {
                cursor: grabbing;
            }
            #controls {
                position: fixed;
                top: 10px;
                left: 10px;
                padding: 6px 8px;
                background: rgba(0, 0, 0, 0.75);
                border-radius: 6px;
                font-size: 12px;
                z-index: 10;
                user-select: none;
            }
            #controls label {
                display: flex;
                align-items: center;
                gap: 4px;
                margin-bottom: 4px;
            }
            #controls input[type="color"] {
                width: 20px;
                height: 20px;
                padding: 0;
                border: none;
                background: transparent;
            }
            #controls input[type="range"] {
                width: 140px;
            }
            #status {
                margin-top: 4px;
                opacity: 0.7;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco,
                    Consolas, "Liberation Mono", "Courier New", monospace;
            }
        </style>
    </head>
    <body>
        <canvas id="view"></canvas>

        <div id="controls">
            <div><strong>Palette</strong></div>
            <label>
                Color
                <input type="color" id="fc" />
            </label>
            <label>
                Glow
                <input type="range" id="bw" min="0" max="100" value="80" />
            </label>
            <div id="status">WASM loadingâ€¦</div>
        </div>

        <!-- Astro: <script src="/mandel.js" is:inline></script> -->
        <script is:inline src="/mandel.js"></script>

        <!-- Astro: <script is:inline> ... </script> -->
        <script>
            (function () {
                const canvas = document.getElementById("view");
                const ctx = canvas.getContext("2d");
                const dpr = window.devicePixelRatio || 1;

                const fc = document.getElementById("fc");
                const bw = document.getElementById("bw");
                const status = document.getElementById("status");

                fc.value = "#00ffff";

                // World view
                let worldCenterX = -0.75;
                let worldCenterY = 0.0;
                let worldScale = 1.5;

                const CIRC_X = -0.75;
                const CIRC_Y = 0.0;
                const CIRC_R = 1.5;

                let fullW = 0;
                let fullH = 0;

                // Last high-quality colored frame
                const baseCanvas = document.createElement("canvas");
                const baseCtx = baseCanvas.getContext("2d");
                let baseValid = false;

                // Grayscale buffer (one byte per pixel, 0..255) from final stage
                let grayBuffer = null;
                let grayW = 0;
                let grayH = 0;

                // Buffer canvas for stage output
                const bufCanvas = document.createElement("canvas");
                const bufCtx = bufCanvas.getContext("2d");

                // Interactive transform applied to baseCanvas
                let viewScale = 1;
                let viewOffsetX = 0;
                let viewOffsetY = 0;

                // WASM API
                let wasmReady = false;
                let initFB = null;
                let getPtr = null;
                let renderFrame = null;

                // WASM framebuffer view (RGBA, grayscale in R/G/B)
                let fbW = 0;
                let fbH = 0;
                let fbPtr = 0;
                let fbView = null;

                // Stages: factor, iter, samplesPerDim
                const STAGES = [
                    { factor: 0.3, iter: 150, samplesDim: 1 }, // quick preview
                    { factor: 1.0, iter: 500, samplesDim: 2 }, // full-res 2x2 samples/pixel
                ];
                const MAX_PIXELS = 5_000_000; // safety cap

                let currentStage = -1;
                let stagePending = false;

                // Interaction timing
                let interactionActive = false;
                let lastInteractionTime = 0;
                const INTERACTION_SETTLE_MS = 150;

                // Panning
                let isPanning = false;
                let panStartX = 0;
                let panStartY = 0;
                let panStartCenterX = 0;
                let panStartCenterY = 0;

                function setStatus(msg) {
                    const mode =
                        currentStage >= 0
                            ? `render-stage=${currentStage}`
                            : interactionActive
                              ? "interactive"
                              : "idle";
                    status.textContent = `${msg} | mode=${mode} | WASM=${wasmReady ? "on" : "off"}`;
                }

                function hexToRgb(hex) {
                    let h = hex.replace("#", "");
                    if (h.length === 3) {
                        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
                    }
                    const num = parseInt(h, 16);
                    return {
                        r: (num >> 16) & 255,
                        g: (num >> 8) & 255,
                        b: num & 255,
                    };
                }

                function getBandWidth() {
                    const raw = parseInt(bw.value, 10) || 0;
                    const sNorm = Math.min(1, Math.max(0, raw / 100));
                    const sInv = 1 - sNorm;
                    const minW = 0.1;
                    const maxW = 0.95;
                    return minW + sInv * (maxW - minW);
                }

                function currentWorldParams() {
                    const aspect = fullW / fullH;
                    const worldWidth = worldScale * 2;
                    const worldHeight = worldWidth / aspect;
                    const worldX0 = worldCenterX - worldWidth / 2;
                    const worldY0 = worldCenterY - worldHeight / 2;
                    return { worldWidth, worldHeight, worldX0, worldY0 };
                }

                function screenToWorld(sx, sy) {
                    const { worldWidth, worldHeight, worldX0, worldY0 } =
                        currentWorldParams();
                    const u = sx / fullW;
                    const v = sy / fullH;
                    const cx = worldX0 + u * worldWidth;
                    const cy = worldY0 + v * worldHeight;
                    return { cx, cy };
                }

                function resize() {
                    const cssW = window.innerWidth;
                    const cssH = window.innerHeight;

                    canvas.style.width = cssW + "px";
                    canvas.style.height = cssH + "px";

                    canvas.width = Math.floor(cssW * dpr);
                    canvas.height = Math.floor(cssH * dpr);

                    fullW = canvas.width;
                    fullH = canvas.height;

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;

                    baseValid = false;
                    grayBuffer = null;
                    grayW = grayH = 0;

                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    if (wasmReady) {
                        fbView = null;
                        requestFullRender();
                    }
                }

                window.addEventListener("resize", () => {
                    resize();
                    markInteraction();
                });

                function markInteraction() {
                    interactionActive = true;
                    lastInteractionTime = performance.now();
                }

                function requestFullRender() {
                    if (!wasmReady) return;
                    currentStage = 0;
                    stagePending = true;
                }

                // JS-only pan: move worldCenter + transform baseCanvas
                canvas.addEventListener("pointerdown", (e) => {
                    isPanning = true;
                    canvas.setPointerCapture(e.pointerId);
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    panStartCenterX = worldCenterX;
                    panStartCenterY = worldCenterY;
                    markInteraction();
                });

                canvas.addEventListener("pointermove", (e) => {
                    if (!isPanning) return;
                    const dx = e.clientX - panStartX;
                    const dy = e.clientY - panStartY;

                    const { worldWidth, worldHeight } = currentWorldParams();

                    worldCenterX =
                        panStartCenterX -
                        (dx / (window.innerWidth || 1)) * worldWidth;
                    worldCenterY =
                        panStartCenterY -
                        (dy / (window.innerHeight || 1)) * worldHeight;

                    viewOffsetX = dx;
                    viewOffsetY = dy;

                    markInteraction();
                });

                function endPan(e) {
                    if (!isPanning) return;
                    isPanning = false;
                    try {
                        canvas.releasePointerCapture(e.pointerId);
                    } catch (_) {}
                    markInteraction();
                }

                canvas.addEventListener("pointerup", endPan);
                canvas.addEventListener("pointercancel", endPan);

                // JS-only zoom: zoom cached frame + update worldScale
                canvas.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();

                        const rect = canvas.getBoundingClientRect();
                        const sx = (e.clientX - rect.left) * dpr;
                        const sy = (e.clientY - rect.top) * dpr;

                        const before = screenToWorld(sx, sy);

                        const delta = -e.deltaY;
                        const zoomFactor = Math.exp(delta * 0.001);
                        worldScale /= zoomFactor;

                        const after = screenToWorld(sx, sy);
                        worldCenterX += before.cx - after.cx;
                        worldCenterY += before.cy - after.cy;

                        const oldScale = viewScale;
                        const newScale = viewScale * zoomFactor;

                        viewOffsetX =
                            sx - (sx - viewOffsetX) * (newScale / oldScale);
                        viewOffsetY =
                            sy - (sy - viewOffsetY) * (newScale / oldScale);
                        viewScale = newScale;

                        markInteraction();
                    },
                    { passive: false },
                );

                // Palette changes: recolor from grayscale if we have it, else full rerender
                function applyPalette() {
                    if (!grayBuffer || grayW !== fullW || grayH !== fullH)
                        return;

                    const N = grayBuffer.length;
                    const out = new Uint8ClampedArray(N * 4);

                    const color = hexToRgb(fc.value);
                    const bandWidth = getBandWidth();

                    let o = 0;
                    for (let i = 0; i < N; i++) {
                        const gNorm = grayBuffer[i] / 255; // 0..1
                        let r, g, b;

                        if (gNorm <= 0) {
                            r = g = b = 0;
                        } else {
                            let w;
                            if (gNorm >= bandWidth) w = 1;
                            else w = gNorm / bandWidth;

                            r = color.r * w;
                            g = color.g * w;
                            b = color.b * w;
                        }

                        out[o++] = r;
                        out[o++] = g;
                        out[o++] = b;
                        out[o++] = 255;
                    }

                    const img = new ImageData(out, grayW, grayH);
                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;
                    baseCtx.putImageData(img, 0, 0);

                    baseValid = true;
                }

                fc.addEventListener("input", () => {
                    if (grayBuffer && grayW === fullW && grayH === fullH) {
                        applyPalette();
                    } else {
                        markInteraction();
                        requestFullRender();
                    }
                });

                bw.addEventListener("input", () => {
                    if (grayBuffer && grayW === fullW && grayH === fullH) {
                        applyPalette();
                    } else {
                        markInteraction();
                        requestFullRender();
                    }
                });

                function drawInteractiveFrame() {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);

                    if (!baseValid) return;

                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(baseCanvas, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                function drawStableBase() {
                    if (!baseValid) return;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(baseCanvas, 0, 0);
                }

                function runStage(stageIndex) {
                    if (
                        !wasmReady ||
                        stageIndex < 0 ||
                        stageIndex >= STAGES.length
                    ) {
                        currentStage = -1;
                        stagePending = false;
                        return;
                    }

                    const stage = STAGES[stageIndex];
                    const baseFactor = stage.factor;
                    const iter = stage.iter;
                    const samplesDim = stage.samplesDim;

                    // Proposed framebuffer size
                    let targetW = Math.max(1, Math.floor(fullW * baseFactor));
                    let targetH = Math.max(1, Math.floor(fullH * baseFactor));
                    let pixels = targetW * targetH;

                    // Clamp by MAX_PIXELS
                    if (pixels > MAX_PIXELS) {
                        const scale = Math.sqrt(MAX_PIXELS / pixels);
                        targetW = Math.max(1, Math.floor(targetW * scale));
                        targetH = Math.max(1, Math.floor(targetH * scale));
                        pixels = targetW * targetH;
                    }

                    fbW = targetW;
                    fbH = targetH;

                    initFB(fbW, fbH);
                    fbPtr = getPtr();

                    if (!Module.HEAPU8 || !Module.HEAPU8.buffer) {
                        setStatus("WASM: no HEAPU8");
                        fbView = null;
                        currentStage = -1;
                        stagePending = false;
                        return;
                    }

                    fbView = new Uint8ClampedArray(
                        Module.HEAPU8.buffer,
                        fbPtr,
                        fbW * fbH * 4,
                    );

                    renderFrame(
                        worldCenterX,
                        worldCenterY,
                        worldScale,
                        iter,
                        samplesDim,
                        CIRC_X,
                        CIRC_Y,
                        CIRC_R,
                    );

                    bufCanvas.width = fbW;
                    bufCanvas.height = fbH;

                    const img = new ImageData(fbView, fbW, fbH);
                    bufCtx.putImageData(img, 0, 0);

                    // Draw grayscale stage to main canvas
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        fbW,
                        fbH,
                        0,
                        0,
                        fullW,
                        fullH,
                    );

                    const effectiveFactor = fbW / fullW;

                    // Final stage: capture grayscale and apply palette in JS
                    if (stageIndex === STAGES.length - 1) {
                        grayW = fbW;
                        grayH = fbH;
                        grayBuffer = new Uint8Array(grayW * grayH);

                        // Copy R channel (grayscale) into grayBuffer
                        for (
                            let i = 0, j = 0;
                            i < grayBuffer.length;
                            i++, j += 4
                        ) {
                            grayBuffer[i] = fbView[j];
                        }

                        applyPalette();
                        baseValid = true;

                        // Reset interactive transform
                        viewScale = 1;
                        viewOffsetX = 0;
                        viewOffsetY = 0;
                    }

                    setStatus(
                        `stage=${stageIndex} baseFactor=${baseFactor} effFactor=${effectiveFactor.toFixed(2)} ` +
                            `iter=${iter} samplesDim=${samplesDim} center=(${worldCenterX.toFixed(6)}, ${worldCenterY.toFixed(6)}) ` +
                            `scale=${worldScale.toExponential(3)}`,
                    );

                    currentStage++;
                    stagePending = currentStage < STAGES.length;
                    if (!stagePending) {
                        currentStage = -1;
                    }
                }

                function loop() {
                    const now = performance.now();

                    if (
                        interactionActive &&
                        now - lastInteractionTime > INTERACTION_SETTLE_MS &&
                        currentStage === -1
                    ) {
                        interactionActive = false;
                        // Reset display transform for the new baked frame
                        viewScale = 1;
                        viewOffsetX = 0;
                        viewOffsetY = 0;
                        requestFullRender();
                    }

                    if (interactionActive) {
                        drawInteractiveFrame();
                    } else if (stagePending) {
                        runStage(currentStage);
                    } else {
                        drawStableBase();
                    }

                    requestAnimationFrame(loop);
                }

                function initAfterWasm() {
                    initFB = Module.cwrap("init_framebuffer", null, [
                        "number",
                        "number",
                    ]);
                    getPtr = Module.cwrap("get_framebuffer_ptr", "number", []);
                    // render_frame(cx, cy, scale, maxIter, samplesPerDim, circx, circy, circr)
                    renderFrame = Module.cwrap("render_frame", null, [
                        "number",
                        "number",
                        "number", // centerX, centerY, scale
                        "number", // maxIter
                        "number", // samplesPerDim
                        "number",
                        "number",
                        "number", // circleX, Y, R
                    ]);

                    wasmReady = true;
                    setStatus("WASM ready");

                    resize();
                    requestFullRender();
                    loop();
                }

                if (typeof Module === "undefined") {
                    window.Module = {};
                }
                Module = Module || {};
                Module.onRuntimeInitialized = initAfterWasm;

                if (Module.calledRun) {
                    initAfterWasm();
                }
            })();
        </script>
    </body>
</html>
