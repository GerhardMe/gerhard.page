<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>
            Mandelbrot WASM (worker, JS pan/zoom, pixel stages, JS palette)
        </title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #eee;
                font-family: system-ui, sans-serif;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
                display: block;
                touch-action: none;
                cursor: grab;
            }
            canvas:active {
                cursor: grabbing;
            }
            #controls {
                position: fixed;
                top: 10px;
                left: 10px;
                padding: 6px 8px;
                background: rgba(0, 0, 0, 0.75);
                border-radius: 6px;
                font-size: 12px;
                z-index: 10;
                user-select: none;
            }
            #controls label {
                display: flex;
                align-items: center;
                gap: 4px;
                margin-bottom: 4px;
            }
            #controls input[type="color"] {
                width: 20px;
                height: 20px;
                padding: 0;
                border: none;
                background: transparent;
            }
            #controls input[type="range"] {
                width: 140px;
            }
            #status {
                margin-top: 4px;
                opacity: 0.7;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco,
                    Consolas, "Liberation Mono", "Courier New", monospace;
            }
        </style>
    </head>
    <body>
        <canvas id="view"></canvas>

        <div id="controls">
            <div><strong>Palette</strong></div>
            <label>
                Color
                <input type="color" id="fc" />
            </label>
            <label>
                Glow
                <input type="range" id="bw" min="0" max="100" value="80" />
            </label>
            <div id="status">WASM worker loading…</div>
        </div>

        <script>
            (function () {
                const canvas = document.getElementById("view");
                const ctx = canvas.getContext("2d");

                const fc = document.getElementById("fc");
                const bw = document.getElementById("bw");
                const status = document.getElementById("status");

                fc.value = "#00ffff";

                // World view in complex plane
                let worldCenterX = -0.75;
                let worldCenterY = 0.0;
                let worldScale = 1.5;

                // Circle cutoff in world coords
                const CIRC_X = -0.75;
                const CIRC_Y = 0.0;
                const CIRC_R = 1.5;

                let fullW = 0;
                let fullH = 0;

                // Last rendered colored frame, used for JS pan/zoom
                const baseCanvas = document.createElement("canvas");
                const baseCtx = baseCanvas.getContext("2d");
                let baseValid = false;

                // Offscreen buffer for each stage
                const bufCanvas = document.createElement("canvas");
                const bufCtx = bufCanvas.getContext("2d");

                // Interactive transform applied to baseCanvas
                let viewScale = 1;
                let viewOffsetX = 0;
                let viewOffsetY = 0;

                // Worker / job state
                let worker = null;
                let workerReady = false;
                let nextJobId = 1;
                let currentJobId = null; // latest job we care about
                let jobInFlight = false;

                // Stored grayscale for palette-only recolor
                let lastGray = null;
                let lastFbW = 0;
                let lastFbH = 0;

                const MAX_ITER = 500;

                const STAGES = [
                    { pixelSize: 64, samplesDim: 1 },
                    { pixelSize: 32, samplesDim: 1 },
                    { pixelSize: 16, samplesDim: 1 },
                    { pixelSize: 8, samplesDim: 1 },
                    { pixelSize: 4, samplesDim: 1 },
                    { pixelSize: 2, samplesDim: 1 },
                    { pixelSize: 1, samplesDim: 1 },
                    { pixelSize: 1, samplesDim: 4 },
                ];

                let currentStage = -1;
                let stagePending = false;

                // Interaction timing
                let interactionActive = false;
                let lastInteractionTime = 0;
                const INTERACTION_SETTLE_MS = 200; // debounce

                // Panning state
                let isPanning = false;
                let panStartX = 0;
                let panStartY = 0;
                let panStartCenterX = 0;
                let panStartCenterY = 0;

                function setStatus(msg) {
                    const mode =
                        currentStage >= 0
                            ? `render-stage=${currentStage}`
                            : interactionActive
                              ? "interactive"
                              : "idle";
                    status.textContent = `${msg} | mode=${mode} | worker=${
                        workerReady ? "on" : "off"
                    }`;
                }

                function hexToRgb(hex) {
                    let h = hex.replace("#", "");
                    if (h.length === 3) {
                        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
                    }
                    const num = parseInt(h, 16);
                    return {
                        r: (num >> 16) & 255,
                        g: (num >> 8) & 255,
                        b: num & 255,
                    };
                }

                // Glow slider: 0 = wide/soft, 100 = thin/bright
                function getBandWidth() {
                    const raw = parseInt(bw.value, 10) || 0;
                    const sNorm = Math.min(1, Math.max(0, raw / 100));
                    const sInv = 1 - sNorm;
                    const minW = 0.1;
                    const maxW = 0.95;
                    return minW + sInv * (maxW - minW);
                }

                function currentWorldParams() {
                    const aspect = fullW / fullH;
                    const worldWidth = worldScale * 2;
                    const worldHeight = worldWidth / aspect;
                    const worldX0 = worldCenterX - worldWidth / 2;
                    const worldY0 = worldCenterY - worldHeight / 2;
                    return { worldWidth, worldHeight, worldX0, worldY0 };
                }

                function screenToWorld(sx, sy) {
                    const { worldWidth, worldHeight, worldX0, worldY0 } =
                        currentWorldParams();
                    const u = sx / fullW;
                    const v = sy / fullH;
                    const cx = worldX0 + u * worldWidth;
                    const cy = worldY0 + v * worldHeight;
                    return { cx, cy };
                }

                function resize() {
                    const cssW = window.innerWidth;
                    const cssH = window.innerHeight;

                    canvas.style.width = cssW + "px";
                    canvas.style.height = cssH + "px";

                    canvas.width = cssW;
                    canvas.height = cssH;

                    fullW = canvas.width;
                    fullH = canvas.height;

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;

                    baseValid = false;
                    viewScale = 1;
                    viewOffsetX = 0;
                    viewOffsetY = 0;

                    lastGray = null;

                    if (workerReady) {
                        requestFullRender();
                    }
                }

                window.addEventListener("resize", () => {
                    resize();
                    markInteraction();
                });

                function markInteraction() {
                    interactionActive = true;
                    lastInteractionTime = performance.now();

                    // Abort current staged render and ignore current worker job
                    stagePending = false;
                    currentStage = -1;
                    currentJobId = null;
                    jobInFlight = false;
                }

                function requestFullRender() {
                    if (!workerReady) return;
                    currentStage = 0;
                    stagePending = true;
                }

                // JS colorization: grayscale (0..255) → RGBA
                function colorizeGray(gray, w, h) {
                    const N = gray.length;
                    const out = new Uint8ClampedArray(N * 4);

                    const color = hexToRgb(fc.value);
                    const bandWidth = getBandWidth();

                    let o = 0;
                    for (let i = 0; i < N; i++) {
                        const gNorm = gray[i] / 255;
                        let r, g, b;

                        if (gNorm <= 0) {
                            r = g = b = 0;
                        } else {
                            let wVal;
                            if (gNorm >= bandWidth) wVal = 1;
                            else wVal = gNorm / bandWidth;

                            r = color.r * wVal;
                            g = color.g * wVal;
                            b = color.b * wVal;
                        }

                        out[o++] = r;
                        out[o++] = g;
                        out[o++] = b;
                        out[o++] = 255;
                    }
                    return out;
                }

                // Re-apply palette to last grayscale frame only in JS
                function applyPaletteToLastGray() {
                    if (!lastGray || lastFbW <= 0 || lastFbH <= 0) return;

                    const colored = colorizeGray(lastGray, lastFbW, lastFbH);

                    bufCanvas.width = lastFbW;
                    bufCanvas.height = lastFbH;
                    const img = new ImageData(colored, lastFbW, lastFbH);
                    bufCtx.putImageData(img, 0, 0);

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;
                    baseCtx.setTransform(1, 0, 0, 1, 0, 0);
                    baseCtx.clearRect(0, 0, fullW, fullH);
                    baseCtx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        lastFbW,
                        lastFbH,
                        0,
                        0,
                        fullW,
                        fullH,
                    );
                    baseValid = true;

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(baseCanvas, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                // JS-only pan
                canvas.addEventListener("pointerdown", (e) => {
                    isPanning = true;
                    canvas.setPointerCapture(e.pointerId);
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    panStartCenterX = worldCenterX;
                    panStartCenterY = worldCenterY;
                    // no markInteraction here
                });

                canvas.addEventListener("pointermove", (e) => {
                    if (!isPanning) return;
                    const dx = e.clientX - panStartX;
                    const dy = e.clientY - panStartY;

                    const { worldWidth, worldHeight } = currentWorldParams();

                    worldCenterX =
                        panStartCenterX -
                        (dx / (window.innerWidth || 1)) * worldWidth;
                    worldCenterY =
                        panStartCenterY -
                        (dy / (window.innerHeight || 1)) * worldHeight;

                    viewOffsetX = dx;
                    viewOffsetY = dy;

                    markInteraction();
                });

                function endPan(e) {
                    if (!isPanning) return;
                    isPanning = false;
                    try {
                        canvas.releasePointerCapture(e.pointerId);
                    } catch (_) {}
                    markInteraction();
                }

                canvas.addEventListener("pointerup", endPan);
                canvas.addEventListener("pointercancel", endPan);

                // JS-only zoom
                canvas.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();

                        const rect = canvas.getBoundingClientRect();
                        const sx = e.clientX - rect.left;
                        const sy = e.clientY - rect.top;

                        const before = screenToWorld(sx, sy);

                        const delta = -e.deltaY;
                        const zoomFactor = Math.exp(delta * 0.001);
                        worldScale /= zoomFactor;

                        const after = screenToWorld(sx, sy);
                        worldCenterX += before.cx - after.cx;
                        worldCenterY += before.cy - after.cy;

                        const oldScale = viewScale;
                        const newScale = viewScale * zoomFactor;

                        viewOffsetX =
                            sx - (sx - viewOffsetX) * (newScale / oldScale);
                        viewOffsetY =
                            sy - (sy - viewOffsetY) * (newScale / oldScale);
                        viewScale = newScale;

                        markInteraction();
                    },
                    { passive: false },
                );

                // Palette changes: JS recolor only, no new WASM
                fc.addEventListener("input", applyPaletteToLastGray);
                bw.addEventListener("input", applyPaletteToLastGray);

                function drawInteractiveFrame() {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);

                    if (!baseValid) return;

                    ctx.setTransform(
                        viewScale,
                        0,
                        0,
                        viewScale,
                        viewOffsetX,
                        viewOffsetY,
                    );
                    ctx.drawImage(baseCanvas, 0, 0);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                function drawStableBase() {
                    if (!baseValid) return;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(baseCanvas, 0, 0);
                }

                function startWorkerJob(stageIndex) {
                    if (!workerReady) return;

                    const stage = STAGES[stageIndex];
                    const pixelSize = stage.pixelSize;
                    const samplesDim = stage.samplesDim;

                    const baseFactor = 1 / pixelSize;
                    const fbW = Math.max(1, Math.floor(fullW * baseFactor));
                    const fbH = Math.max(1, Math.floor(fullH * baseFactor));

                    const jobId = nextJobId++;
                    currentJobId = jobId;
                    jobInFlight = true;

                    const cxSnap = worldCenterX;
                    const cySnap = worldCenterY;
                    const scaleSnap = worldScale;

                    worker.postMessage({
                        type: "render",
                        jobId,
                        fbW,
                        fbH,
                        worldCenterX: cxSnap,
                        worldCenterY: cySnap,
                        worldScale: scaleSnap,
                        maxIter: MAX_ITER,
                        samplesDim,
                        circX: CIRC_X,
                        circY: CIRC_Y,
                        circR: CIRC_R,
                    });

                    setStatus(
                        `sending stage=${stageIndex} pixelSize=${pixelSize} fb=${fbW}x${fbH}`,
                    );
                }

                function handleWorkerFrame(msg) {
                    const {
                        jobId,
                        fbW,
                        fbH,
                        gray,
                        worldCenterX: jobCx,
                        worldCenterY: jobCy,
                        worldScale: jobScale,
                    } = msg;

                    const EPS = 1e-12;

                    // stale jobId → ignore and clear inFlight
                    if (currentJobId === null || jobId !== currentJobId) {
                        jobInFlight = false;
                        return;
                    }

                    // viewbox mismatch → ignore and clear inFlight
                    if (
                        Math.abs(jobCx - worldCenterX) > EPS ||
                        Math.abs(jobCy - worldCenterY) > EPS ||
                        Math.abs(jobScale - worldScale) > EPS
                    ) {
                        jobInFlight = false;
                        return;
                    }

                    jobInFlight = false;

                    // Store grayscale for palette-only recolor
                    lastGray = new Uint8Array(gray);
                    lastFbW = fbW;
                    lastFbH = fbH;

                    const colored = colorizeGray(lastGray, fbW, fbH);

                    bufCanvas.width = fbW;
                    bufCanvas.height = fbH;
                    const img = new ImageData(colored, fbW, fbH);
                    bufCtx.putImageData(img, 0, 0);

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, fullW, fullH);
                    ctx.drawImage(
                        bufCanvas,
                        0,
                        0,
                        fbW,
                        fbH,
                        0,
                        0,
                        fullW,
                        fullH,
                    );

                    baseCanvas.width = fullW;
                    baseCanvas.height = fullH;
                    baseCtx.clearRect(0, 0, fullW, fullH);
                    baseCtx.drawImage(canvas, 0, 0);
                    baseValid = true;

                    setStatus(`done stage=${currentStage} fb=${fbW}x${fbH}`);

                    currentStage++;
                    stagePending = currentStage < STAGES.length;
                    if (!stagePending) {
                        currentStage = -1;
                        setStatus("idle");
                    }
                }

                function loop() {
                    const now = performance.now();

                    // Debounced start: only when pointer is up and no input for INTERACTION_SETTLE_MS
                    if (
                        interactionActive &&
                        !isPanning &&
                        now - lastInteractionTime > INTERACTION_SETTLE_MS &&
                        currentStage === -1 &&
                        workerReady
                    ) {
                        // we're committing this viewbox; bake current screen into baseCanvas
                        // so there is no visual jump when we leave interactive mode
                        try {
                            const snapshot = ctx.getImageData(
                                0,
                                0,
                                fullW,
                                fullH,
                            );
                            baseCanvas.width = fullW;
                            baseCanvas.height = fullH;
                            baseCtx.putImageData(snapshot, 0, 0);
                            baseValid = true;
                        } catch (_) {
                            // ignore; we'll just reuse previous baseCanvas
                        }

                        interactionActive = false;
                        viewScale = 1;
                        viewOffsetX = 0;
                        viewOffsetY = 0;
                        requestFullRender();
                    }

                    if (interactionActive) {
                        drawInteractiveFrame();
                    } else if (stagePending && !jobInFlight) {
                        startWorkerJob(currentStage);
                    } else {
                        drawStableBase();
                    }

                    requestAnimationFrame(loop);
                }

                function initWorker() {
                    worker = new Worker("/mandel-worker.js");
                    worker.onmessage = (e) => {
                        const msg = e.data;
                        if (msg.type === "ready") {
                            workerReady = true;
                            setStatus("worker ready");
                            resize();
                            requestFullRender();
                            return;
                        }
                        if (msg.type === "error") {
                            jobInFlight = false;
                            stagePending = false;
                            currentStage = -1;
                            setStatus("worker error: " + msg.message);
                            return;
                        }
                        if (msg.type === "frame") {
                            handleWorkerFrame(msg);
                        }
                    };
                }

                function init() {
                    initWorker();
                    loop();
                }

                init();
            })();
        </script>
    </body>
</html>
